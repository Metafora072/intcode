[
  {
    "slug": "reverse-linked-list",
    "title": "Reverse Linked List",
    "difficulty": "EASY",
    "tags": ["链表", "双指针"],
    "content": "给定单链表头节点，反转链表并输出节点值（ACM 模式，自行定义 ListNode、读取 stdin 并打印 stdout）。",
    "input_description": "第一行整数 n，第二行 n 个整数（可为负），表示链表节点值；n=0 表示空链表。",
    "output_description": "输出反转后的链表节点值，使用空格分隔，无多余空格；空链表输出空行。",
    "constraints": "$0 \\le n \\le 10^5,\\ |val| \\le 10^9$",
    "testcases": [
      {"input_text": "5\n1 2 3 4 5\n", "output_text": "5 4 3 2 1\n", "is_sample": true},
      {"input_text": "0\n", "output_text": "\n", "is_sample": true},
      {"input_text": "1\n42\n", "output_text": "42\n", "is_sample": false},
      {"input_text": "2\n1 2\n", "output_text": "2 1\n", "is_sample": false},
      {"input_text": "6\n-3 -2 -1 0 1 2\n", "output_text": "2 1 0 -1 -2 -3\n", "is_sample": false},
      {"input_text": "10\n1 2 3 4 5 6 7 8 9 10\n", "output_text": "10 9 8 7 6 5 4 3 2 1\n", "is_sample": false},
      {"input_text": "3\n5 5 5\n", "output_text": "5 5 5\n", "is_sample": false},
      {"input_text": "4\n1000000000 -1000000000 7 0\n", "output_text": "0 7 -1000000000 1000000000\n", "is_sample": false},
      {"input_text": "7\n9 8 7 6 5 4 3\n", "output_text": "3 4 5 6 7 8 9\n", "is_sample": false},
      {"input_text": "8\n1 -1 2 -2 3 -3 4 -4\n", "output_text": "-4 4 -3 3 -2 2 -1 1\n", "is_sample": false},
      {"input_text": "1\n0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "2\n-2147483648 2147483647\n", "output_text": "2147483647 -2147483648\n", "is_sample": false}
    ]
  },
  {
    "slug": "climbing-stairs",
    "title": "Climbing Stairs",
    "difficulty": "EASY",
    "tags": ["动态规划"],
    "content": "一次可以爬 1 或 2 阶台阶，问到达第 n 阶的不同方式数（ACM 模式，直接读写 stdin/stdout）。",
    "input_description": "一行一个整数 n。",
    "output_description": "一行一个整数，表示方案数。",
    "constraints": "$0 \\le n \\le 45$",
    "testcases": [
      {"input_text": "1\n", "output_text": "1\n", "is_sample": true},
      {"input_text": "2\n", "output_text": "2\n", "is_sample": true},
      {"input_text": "3\n", "output_text": "3\n", "is_sample": false},
      {"input_text": "4\n", "output_text": "5\n", "is_sample": false},
      {"input_text": "5\n", "output_text": "8\n", "is_sample": false},
      {"input_text": "0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "10\n", "output_text": "89\n", "is_sample": false},
      {"input_text": "20\n", "output_text": "10946\n", "is_sample": false},
      {"input_text": "30\n", "output_text": "1346269\n", "is_sample": false},
      {"input_text": "35\n", "output_text": "14930352\n", "is_sample": false},
      {"input_text": "45\n", "output_text": "1836311903\n", "is_sample": false}
    ]
  },
  {
    "slug": "maximum-subarray",
    "title": "Maximum Subarray",
    "difficulty": "MEDIUM",
    "tags": ["数组", "动态规划"],
    "content": "给定整数数组，找出具有最大和的连续子数组，并输出其和（ACM 模式，直接读写 stdin/stdout）。",
    "input_description": "第一行整数 n，第二行 n 个整数，可为负。",
    "output_description": "输出一个整数，表示最大子数组和。",
    "constraints": "$1 \\le n \\le 10^{5},\\ |nums[i]| \\le 10^{9}$",
    "testcases": [
      {"input_text": "5\n-1 -2 -3 -4 -5\n", "output_text": "-1\n", "is_sample": true},
      {"input_text": "9\n-2 1 -3 4 -1 2 1 -5 4\n", "output_text": "6\n", "is_sample": true},
      {"input_text": "1\n5\n", "output_text": "5\n", "is_sample": false},
      {"input_text": "1\n-7\n", "output_text": "-7\n", "is_sample": false},
      {"input_text": "4\n1 2 3 4\n", "output_text": "10\n", "is_sample": false},
      {"input_text": "6\n-1 4 -2 5 -5 2\n", "output_text": "7\n", "is_sample": false},
      {"input_text": "6\n0 0 0 -1 0 0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "6\n-2 -3 -1 -5 -4 -6\n", "output_text": "-1\n", "is_sample": false},
      {"input_text": "8\n-2 -1 -3 -4 -1 -2 -1 -5\n", "output_text": "-1\n", "is_sample": false},
      {"input_text": "10\n1 -2 3 10 -4 7 2 -5 6 1\n", "output_text": "18\n", "is_sample": false},
      {"input_text": "5\n1000000000 -1 1000000000 -1 1000000000\n", "output_text": "2999999998\n", "is_sample": false},
      {"input_text": "7\n-2 1 -3 4 -1 2 1\n", "output_text": "6\n", "is_sample": false}
    ]
  },
  {
    "slug": "valid-parentheses",
    "title": "Valid Parentheses",
    "difficulty": "EASY",
    "tags": ["栈", "字符串"],
    "content": "判断由 '()[]{}' 组成的字符串是否合法（成对且顺序正确），输出 true/false（小写）。",
    "input_description": "一行字符串 s，仅包含括号字符，长度可为 0。",
    "output_description": "合法输出 \"true\"，否则输出 \"false\"。",
    "constraints": "$0 \\le |s| \\le 10^{5}$",
    "testcases": [
      {"input_text": "()\n", "output_text": "true\n", "is_sample": true},
      {"input_text": "()[]{}\n", "output_text": "true\n", "is_sample": true},
      {"input_text": "(]\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "([)]\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "{[]}\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "((((\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "))))\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "([]{})\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "{[()()]}\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "(([]{})\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "[({})](())\n", "output_text": "true\n", "is_sample": false}
    ]
  },
  {
    "slug": "move-zeroes",
    "title": "Move Zeroes",
    "difficulty": "EASY",
    "tags": ["数组", "双指针"],
    "content": "给定数组，将所有 0 移动到末尾，同时保持非零元素相对顺序（原地），输出处理后的数组。",
    "input_description": "第一行整数 n，第二行 n 个整数。",
    "output_description": "输出移动后的数组，使用空格分隔。",
    "constraints": "$1 \\le n \\le 10^{5},\\ |nums[i]| \\le 10^{9}$",
    "testcases": [
      {"input_text": "5\n0 1 0 3 12\n", "output_text": "1 3 12 0 0\n", "is_sample": true},
      {"input_text": "4\n1 0 2 3\n", "output_text": "1 2 3 0\n", "is_sample": true},
      {"input_text": "3\n0 0 0\n", "output_text": "0 0 0\n", "is_sample": false},
      {"input_text": "3\n1 2 3\n", "output_text": "1 2 3\n", "is_sample": false},
      {"input_text": "6\n0 1 0 0 2 3\n", "output_text": "1 2 3 0 0 0\n", "is_sample": false},
      {"input_text": "6\n4 5 6 0 0 0\n", "output_text": "4 5 6 0 0 0\n", "is_sample": false},
      {"input_text": "5\n-1 0 -2 0 -3\n", "output_text": "-1 -2 -3 0 0\n", "is_sample": false},
      {"input_text": "7\n0 0 1 0 3 0 5\n", "output_text": "1 3 5 0 0 0 0\n", "is_sample": false},
      {"input_text": "1\n0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "2\n0 5\n", "output_text": "5 0\n", "is_sample": false},
      {"input_text": "8\n9 8 0 7 6 0 5 0\n", "output_text": "9 8 7 6 5 0 0 0\n", "is_sample": false}
    ]
  },
  {
    "slug": "add-two-numbers",
    "title": "两数相加",
    "difficulty": "MEDIUM",
    "tags": ["链表", "模拟"],
    "content": "给定两个非空链表，表示两个非负整数，最低位在链表头部（逆序存储）。请将两数相加，并以相同格式返回结果链表。你需要：1）自行定义链表节点结构；2）从标准输入读取长度与节点值并构造链表；3）完成按位相加（处理进位）；4）按逆序输出结果链表。",
    "input_description": "第一行整数 n1，第二行 n1 个数字（0-9），从低位到高位给出第一个数；第三行整数 n2，第四行 n2 个数字（0-9），从低位到高位给出第二个数。n1、n2 均 ≥ 1。",
    "output_description": "输出相加后的链表节点值，仍按从低位到高位的顺序，数字之间用空格分隔，行尾换行。结果可能比输入链表长 1 位（有进位）。",
    "constraints": "$1 \\le n1, n2 \\le 10^{5}$，数字为 0-9，结果可能需要进位。",
    "testcases": [
      {"input_text": "3\n2 4 3\n3\n5 6 4\n", "output_text": "7 0 8\n", "is_sample": true, "sample_explanation": "342+465=807，逆序输出为 7 0 8"},
      {"input_text": "1\n0\n1\n0\n", "output_text": "0\n", "is_sample": true, "sample_explanation": "0+0=0，仅一位"},
      {"input_text": "1\n9\n1\n9\n", "output_text": "8 1\n", "is_sample": false},
      {"input_text": "2\n9 9\n1\n1\n", "output_text": "0 0 1\n", "is_sample": false},
      {"input_text": "4\n9 9 9 9\n4\n9 9 9 9\n", "output_text": "8 9 9 9 1\n", "is_sample": false},
      {"input_text": "5\n1 2 3 4 5\n3\n9 9 9\n", "output_text": "0 2 3 5 5\n", "is_sample": false},
      {"input_text": "3\n0 0 1\n2\n0 9\n", "output_text": "0 9 1\n", "is_sample": false},
      {"input_text": "6\n9 9 9 9 9 9\n1\n1\n", "output_text": "0 0 0 0 0 0 1\n", "is_sample": false},
      {"input_text": "2\n5 6\n3\n5 4 9\n", "output_text": "0 1 0 1\n", "is_sample": false},
      {"input_text": "5\n2 0 0 0 1\n1\n9\n", "output_text": "1 0 0 0 1\n", "is_sample": false}
    ]
  },
  {
    "slug": "longest-substring-without-repeating-characters",
    "title": "无重复字符的最长子串",
    "difficulty": "MEDIUM",
    "tags": ["字符串", "滑动窗口"],
    "content": "给定字符串 s，求其中不包含重复字符的最长连续子串长度。子串必须连续，答案是长度整数。需要注意：空串返回 0；出现重复时需重新调整窗口。",
    "input_description": "一行字符串 s，可包含任意可见 ASCII 字符，长度可为 0。",
    "output_description": "输出一个整数，为最长无重复字符子串的长度。",
    "constraints": "$0 \\le |s| \\le 10^{5}$",
    "testcases": [
      {"input_text": "abcabcbb\n", "output_text": "3\n", "is_sample": true, "sample_explanation": "最长无重复子串为 \"abc\"，长度 3"},
      {"input_text": "bbbbb\n", "output_text": "1\n", "is_sample": true, "sample_explanation": "所有字符相同，最长为任意单个字符，长度 1"},
      {"input_text": "pwwkew\n", "output_text": "3\n", "is_sample": false},
      {"input_text": "\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "a\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "au\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "dvdf\n", "output_text": "3\n", "is_sample": false},
      {"input_text": "abba\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "tmmzuxt\n", "output_text": "5\n", "is_sample": false},
      {"input_text": "anviaj\n", "output_text": "5\n", "is_sample": false},
      {"input_text": "abcddefgh\n", "output_text": "5\n", "is_sample": false}
    ]
  },
  {
    "slug": "median-of-two-sorted-arrays",
    "title": "两个有序数组的中位数",
    "difficulty": "HARD",
    "tags": ["二分查找", "数组"],
    "content": "给定两个升序数组 nums1、nums2，求合并后有序序列的中位数，要求 O(log(m+n)) 时间。若总长度为偶数，中位数为中间两数的平均值（可能出现 .5）。可按双数组二分或其他等价 O(log(m+n)) 解法实现。",
    "input_description": "第一行整数 m，第二行 m 个升序整数；第三行整数 n，第四行 n 个升序整数。m 或 n 可为 0，若为 0 对应行为空。",
    "output_description": "输出中位数（整数或小数），行尾换行。",
    "constraints": "$0 \\le m,n \\le 10^{5}$，数组元素绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "2\n1 3\n2\n2 4\n", "output_text": "2.5\n", "is_sample": true, "sample_explanation": "合并序列 [1,2,3,4]，中位数为 (2+3)/2"},
      {"input_text": "1\n1\n1\n2\n", "output_text": "1.5\n", "is_sample": true, "sample_explanation": "合并后 [1,2]，中位数 (1+2)/2"},
      {"input_text": "0\n\n1\n5\n", "output_text": "5\n", "is_sample": false},
      {"input_text": "3\n1 2 3\n0\n\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "4\n1 3 8 9\n4\n7 11 18 19\n", "output_text": "9.5\n", "is_sample": false},
      {"input_text": "5\n-5 -3 -1 0 2\n4\n-2 -1 3 4\n", "output_text": "-0.5\n", "is_sample": false},
      {"input_text": "1\n1000000000\n1\n1000000000\n", "output_text": "1000000000\n", "is_sample": false},
      {"input_text": "2\n1 2\n2\n3 4\n", "output_text": "2.5\n", "is_sample": false},
      {"input_text": "3\n1 2 5\n3\n3 4 6\n", "output_text": "3.5\n", "is_sample": false},
      {"input_text": "5\n1 2 3 4 5\n1\n6\n", "output_text": "3.5\n", "is_sample": false}
    ]
  },
  {
    "slug": "longest-palindromic-substring",
    "title": "最长回文子串",
    "difficulty": "MEDIUM",
    "tags": ["字符串", "中心扩展"],
    "content": "给定字符串 s，找到其中最长的回文子串（必须连续），并输出该子串。可用中心扩展或 DP。若存在长度相同的多个回文，输出任意一个即可。",
    "input_description": "一行字符串 s，长度可为 0。",
    "output_description": "输出一个字符串，为 s 的最长回文子串。",
    "constraints": "$0 \\le |s| \\le 10^{4}$",
    "testcases": [
      {"input_text": "cbbd\n", "output_text": "bb\n", "is_sample": true, "sample_explanation": "最长回文为 \"bb\"，长度 2"},
      {"input_text": "babad\n", "output_text": "bab\n", "is_sample": true, "sample_explanation": "可得 \"bab\" 或 \"aba\"，返回任意一条即可"},
      {"input_text": "a\n", "output_text": "a\n", "is_sample": false},
      {"input_text": "aaaa\n", "output_text": "aaaa\n", "is_sample": false},
      {"input_text": "abcde\n", "output_text": "a\n", "is_sample": false},
      {"input_text": "racecar\n", "output_text": "racecar\n", "is_sample": false},
      {"input_text": "abccba\n", "output_text": "abccba\n", "is_sample": false},
      {"input_text": "forgeeksskeegfor\n", "output_text": "geeksskeeg\n", "is_sample": false},
      {"input_text": "abacdfgdcaba\n", "output_text": "aba\n", "is_sample": false},
      {"input_text": "abcdedcba\n", "output_text": "abcdedcba\n", "is_sample": false},
      {"input_text": "abb\n", "output_text": "bb\n", "is_sample": false}
    ]
  },
  {
    "slug": "regular-expression-matching",
    "title": "正则表达式匹配",
    "difficulty": "HARD",
    "tags": ["动态规划", "字符串"],
    "content": "实现支持 '.' 和 '*' 的正则匹配，判断模式串 p 能否完整匹配文本串 s。'.' 匹配任意单字符，'*' 匹配其前一个字符零次或多次，要求整串匹配。需考虑空串、连续 *、以及多段匹配状态转移。",
    "input_description": "第一行文本串 s，第二行模式串 p。",
    "output_description": "若匹配输出 \"true\"，否则输出 \"false\"，行尾换行。",
    "constraints": "$0 \\le |s|,|p| \\le 200$",
    "testcases": [
      {"input_text": "aa\na\n", "output_text": "false\n", "is_sample": true, "sample_explanation": "模式只有一个 'a'，无法覆盖两个字符"},
      {"input_text": "aa\na*\n", "output_text": "true\n", "is_sample": true, "sample_explanation": "a* 可匹配任意个数的 a，匹配整串"},
      {"input_text": "ab\n.*\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "aab\nc*a*b\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "mississippi\nmis*is*p*.\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "aaa\na*a\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "aaa\naaa\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "aaa\naab*\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "abcd\n.*d\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "abc\n.*c\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "abc\n.*d\n", "output_text": "false\n", "is_sample": false}
    ]
  },
  {
    "slug": "container-with-most-water",
    "title": "盛最多水的容器",
    "difficulty": "MEDIUM",
    "tags": ["双指针", "贪心"],
    "content": "给定数组 heights，每个元素表示一条垂直线的高度（坐标为索引）。选择两条线与 x 轴构成容器，求最多能装多少水。面积 = 横距 * 较短高度，要求返回最大面积整数。常用双指针贪心。",
    "input_description": "第一行整数 n，第二行 n 个非负整数表示高度。",
    "output_description": "输出最大容积的整数值，行尾换行。",
    "constraints": "$2 \\le n \\le 10^{5},\\ 0 \\le height[i] \\le 10^{9}$",
    "testcases": [
      {"input_text": "9\n1 8 6 2 5 4 8 3 7\n", "output_text": "49\n", "is_sample": true, "sample_explanation": "选索引 1 和 8，高度 min(8,7)=7，宽 7，面积 49"},
      {"input_text": "2\n1 1\n", "output_text": "1\n", "is_sample": true, "sample_explanation": "仅两条线，宽 1，高 1"},
      {"input_text": "5\n1 2 3 4 5\n", "output_text": "6\n", "is_sample": false},
      {"input_text": "5\n5 4 3 2 1\n", "output_text": "6\n", "is_sample": false},
      {"input_text": "5\n0 0 0 0 0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "8\n2 3 10 5 7 8 9 1\n", "output_text": "36\n", "is_sample": false},
      {"input_text": "3\n2 2 2\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "6\n1 3 2 5 25 24\n", "output_text": "24\n", "is_sample": false},
      {"input_text": "6\n1 2 1 2 1 2\n", "output_text": "6\n", "is_sample": false},
      {"input_text": "7\n6 4 3 1 4 6 99\n", "output_text": "36\n", "is_sample": false}
    ]
  },
  {
    "slug": "3sum",
    "title": "三数之和",
    "difficulty": "MEDIUM",
    "tags": ["数组", "双指针", "排序"],
    "content": "给定整数数组 nums，找出所有和为 0 的不重复三元组。需先排序，再双指针去重。输出时每个三元组内部按非降序排列，多个三元组按字典序逐行输出；若不存在则输出 \"NONE\"。",
    "input_description": "第一行整数 n，第二行 n 个整数。",
    "output_description": "每行一个三元组，格式 \"a b c\"，按题意排序；若没有解，输出 \"NONE\"。",
    "constraints": "$3 \\le n \\le 10^{4},\\ |nums[i]| \\le 10^{9}$",
    "testcases": [
      {"input_text": "6\n-1 0 1 2 -1 -4\n", "output_text": "-1 -1 2\n-1 0 1\n", "is_sample": true, "sample_explanation": "排序后通过双指针得到两组唯一解"},
      {"input_text": "3\n0 0 0\n", "output_text": "0 0 0\n", "is_sample": true, "sample_explanation": "三零相加为 0，仅这一组"},
      {"input_text": "4\n1 2 -2 -1\n", "output_text": "NONE\n", "is_sample": false},
      {"input_text": "5\n-2 0 1 1 2\n", "output_text": "-2 0 2\n-2 1 1\n", "is_sample": false},
      {"input_text": "7\n-4 -2 -2 -2 0 1 2\n", "output_text": "-4 2 2\n-2 0 2\n", "is_sample": false},
      {"input_text": "5\n-1 -1 -1 2 2\n", "output_text": "-1 -1 2\n", "is_sample": false},
      {"input_text": "8\n-1 0 1 0 0 0 0 0\n", "output_text": "-1 0 1\n0 0 0\n", "is_sample": false},
      {"input_text": "5\n3 -2 -1 0 -2\n", "output_text": "-2 -1 3\n", "is_sample": false},
      {"input_text": "6\n2 2 -4 0 0 0\n", "output_text": "-4 2 2\n0 0 0\n", "is_sample": false},
      {"input_text": "4\n-1000000000 0 0 1000000000\n", "output_text": "-1000000000 0 1000000000\n", "is_sample": false},
      {"input_text": "6\n-3 -3 0 1 2 4\n", "output_text": "-3 1 2\n", "is_sample": false}
    ]
  },
  {
    "slug": "letter-combinations-of-a-phone-number",
    "title": "电话号码的字母组合",
    "difficulty": "MEDIUM",
    "tags": ["回溯", "字符串"],
    "content": "给定仅包含数字 2-9 的字符串，返回所有可能的字母组合（经典电话键映射）。可以用回溯生成，最终结果按字典序输出。",
    "input_description": "一行数字字符串 digits（长度可为 0）。",
    "output_description": "输出所有组合，按字典序，使用空格分隔；若为空则输出空行。",
    "constraints": "$0 \\le |digits| \\le 10$",
    "testcases": [
      {"input_text": "23\n", "output_text": "ad ae af bd be bf cd ce cf\n", "is_sample": true, "sample_explanation": "2->abc, 3->def，笛卡尔积得到 9 种"},
      {"input_text": "2\n", "output_text": "a b c\n", "is_sample": true, "sample_explanation": "单个数字 2 只有 a/b/c 三种"},
      {"input_text": "\n", "output_text": "\n", "is_sample": false},
      {"input_text": "9\n", "output_text": "w x y z\n", "is_sample": false},
      {"input_text": "79\n", "output_text": "pw px py pz qw qx qy qz rw rx ry rz sw sx sy sz\n", "is_sample": false},
      {"input_text": "7\n", "output_text": "p q r s\n", "is_sample": false},
      {"input_text": "234\n", "output_text": "adg adh adi aeg aeh aei afg afh afi bdg bdh bdi beg beh bei bfg bfh bfi cdg cdh cdi ceg ceh cei cfg cfh cfi\n", "is_sample": false},
      {"input_text": "88\n", "output_text": "tt tu tv ut uu uv vt vu vv\n", "is_sample": false},
      {"input_text": "222\n", "output_text": "aaa aab aac aba abb abc aca acb acc baa bab bac bba bbb bbc bca bcb bcc caa cab cac cba cbb cbc cca ccb ccc\n", "is_sample": false},
      {"input_text": "56\n", "output_text": "jm jn jo km kn ko lm ln lo\n", "is_sample": false}
    ]
  },
  {
    "slug": "remove-nth-node-from-end-of-list",
    "title": "删除链表的倒数第 N 个节点",
    "difficulty": "MEDIUM",
    "tags": ["链表", "双指针"],
    "content": "给定单链表头节点和整数 n，删除倒数第 n 个节点，返回新的头节点。可用双指针先走 n 再同步走。需自行定义链表结构、读入链表并输出结果。",
    "input_description": "第一行整数 nlen，第二行 nlen 个整数表示链表节点值；第三行整数 k，表示需要删除的倒数第 k 个节点。保证 1 ≤ k ≤ nlen。",
    "output_description": "输出删除后链表的节点值，使用空格分隔；若删除后为空，输出空行。",
    "constraints": "$1 \\le nlen \\le 10^{5}$，节点值绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "5\n1 2 3 4 5\n2\n", "output_text": "1 2 3 5\n", "is_sample": true, "sample_explanation": "倒数第 2 个是节点 4，删除后余 1 2 3 5"},
      {"input_text": "1\n10\n1\n", "output_text": "\n", "is_sample": true, "sample_explanation": "唯一节点被删，链表为空"},
      {"input_text": "2\n1 2\n2\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "2\n1 2\n1\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "3\n1 2 3\n3\n", "output_text": "2 3\n", "is_sample": false},
      {"input_text": "4\n5 5 5 5\n2\n", "output_text": "5 5 5\n", "is_sample": false},
      {"input_text": "6\n1 2 3 4 5 6\n6\n", "output_text": "2 3 4 5 6\n", "is_sample": false},
      {"input_text": "6\n1 2 3 4 5 6\n1\n", "output_text": "1 2 3 4 5\n", "is_sample": false},
      {"input_text": "7\n1 1 1 1 1 1 1\n4\n", "output_text": "1 1 1 1 1 1\n", "is_sample": false},
      {"input_text": "5\n9 8 7 6 5\n3\n", "output_text": "9 8 6 5\n", "is_sample": false}
    ]
  },
  {
    "slug": "merge-two-sorted-lists",
    "title": "合并两个有序链表",
    "difficulty": "EASY",
    "tags": ["链表", "归并"],
    "content": "将两个升序单链表合并为一个新的升序链表，返回合并后的表头。需要自行定义链表结构、读入链表并输出结果。可用双指针逐步归并。",
    "input_description": "第一行整数 n1，第二行 n1 个整数（升序）表示第一个链表；第三行整数 n2，第四行 n2 个整数（升序）表示第二个链表。n1 或 n2 可为 0，若为 0 则对应行为空行。",
    "output_description": "输出合并后的链表节点值，空格分隔，行尾换行；若合并后为空，输出空行。",
    "constraints": "$0 \\le n1,n2 \\le 10^{5}$，节点值绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "3\n1 2 4\n3\n1 3 4\n", "output_text": "1 1 2 3 4 4\n", "is_sample": true, "sample_explanation": "两个有序链表头部较小者先出，最终归并为升序"},
      {"input_text": "0\n\n3\n1 3 5\n", "output_text": "1 3 5\n", "is_sample": true, "sample_explanation": "第一个链表为空，结果等于第二个链表"},
      {"input_text": "2\n1 2\n0\n\n", "output_text": "1 2\n", "is_sample": false},
      {"input_text": "1\n2\n1\n1\n", "output_text": "1 2\n", "is_sample": false},
      {"input_text": "4\n-3 -1 0 2\n3\n-2 1 3\n", "output_text": "-3 -2 -1 0 1 2 3\n", "is_sample": false},
      {"input_text": "3\n5 5 5\n3\n5 5 5\n", "output_text": "5 5 5 5 5 5\n", "is_sample": false},
      {"input_text": "5\n1 3 5 7 9\n5\n2 4 6 8 10\n", "output_text": "1 2 3 4 5 6 7 8 9 10\n", "is_sample": false},
      {"input_text": "1\n0\n1\n0\n", "output_text": "0 0\n", "is_sample": false},
      {"input_text": "2\n1000000000 2000000000\n2\n-2000000000 -1000000000\n", "output_text": "-2000000000 -1000000000 1000000000 2000000000\n", "is_sample": false},
      {"input_text": "3\n1 4 7\n3\n2 3 6\n", "output_text": "1 2 3 4 6 7\n", "is_sample": false}
    ]
  },
  {
    "slug": "generate-parentheses",
    "title": "括号生成",
    "difficulty": "MEDIUM",
    "tags": ["回溯", "字符串"],
    "content": "给定 n，生成所有由 n 对括号组成且合法的括号序列。可用回溯记录已用左右括号数量，确保任意前缀左括号不少于右括号。",
    "input_description": "一行整数 n。",
    "output_description": "按字典序输出所有合法括号序列，每行一个；若 n=0 输出空行。",
    "constraints": "$0 \\le n \\le 10$",
    "testcases": [
      {"input_text": "1\n", "output_text": "()\n", "is_sample": true, "sample_explanation": "n=1 只有一组括号"},
      {"input_text": "3\n", "output_text": "((()))\n(()())\n(())()\n()(())\n()()()\n", "is_sample": true, "sample_explanation": "标准 3 对括号所有合法序列，共 5 个"},
      {"input_text": "0\n", "output_text": "\n", "is_sample": false},
      {"input_text": "2\n", "output_text": "(())\n()()\n", "is_sample": false},
      {"input_text": "4\n", "output_text": "(((())))\n((()()))\n((())())\n((()))()\n(()(()))\n(()()())\n(()())()\n(())(())\n(())()()\n()((()))\n()(()())\n()(())()\n()()(())\n()()()()\n", "is_sample": false}
    ]
  },
  {
    "slug": "merge-k-sorted-lists",
    "title": "合并 K 个升序链表",
    "difficulty": "HARD",
    "tags": ["链表", "优先队列", "分治"],
    "content": "给定 k 个升序单链表，将它们合并为一个升序链表。可用最小堆或分治归并。需自行定义链表结构、读入并输出链表。",
    "input_description": "第一行整数 k；之后 k 行，每行先给出 len，然后跟随 len 个升序整数。len 可为 0 表示空链表。",
    "output_description": "输出合并后的链表节点值，空格分隔；若为空输出空行。",
    "constraints": "$0 \\le k \\le 10^{5}$，总节点数不超过 $10^{5}$。",
    "testcases": [
      {"input_text": "3\n3 1 4 5\n3 1 3 4\n2 2 6\n", "output_text": "1 1 2 3 4 4 5 6\n", "is_sample": true, "sample_explanation": "三表均升序，堆/分治合并后整体升序"},
      {"input_text": "1\n0\n", "output_text": "\n", "is_sample": true, "sample_explanation": "唯一链表为空，结果为空"},
      {"input_text": "2\n1 1\n1 0\n", "output_text": "0 1\n", "is_sample": false},
      {"input_text": "2\n4 -10 -5 0 10\n3 -6 -2 8\n", "output_text": "-10 -6 -5 -2 0 8 10\n", "is_sample": false},
      {"input_text": "3\n0\n0\n1 5\n", "output_text": "5\n", "is_sample": false},
      {"input_text": "3\n2 1 2\n2 1 3\n2 2 3\n", "output_text": "1 1 2 2 3 3\n", "is_sample": false},
      {"input_text": "2\n3 5 5 5\n3 5 6 7\n", "output_text": "5 5 5 5 6 7\n", "is_sample": false},
      {"input_text": "3\n2 -2147483648 0\n2 1 2147483647\n1 0\n", "output_text": "-2147483648 0 0 1 2147483647\n", "is_sample": false}
    ]
  },
  {
    "slug": "longest-valid-parentheses",
    "title": "最长有效括号",
    "difficulty": "HARD",
    "tags": ["栈", "动态规划", "双指针"],
    "content": "给定只含 '(' 和 ')' 的字符串，求最长的合法括号连续子串长度。可用栈、双向扫描或 DP 维护。",
    "input_description": "一行括号字符串 s，长度可为 0。",
    "output_description": "输出一个整数，表示最长有效括号子串长度。",
    "constraints": "$0 \\le |s| \\le 10^{5}$",
    "testcases": [
      {"input_text": "(()\n", "output_text": "2\n", "is_sample": true, "sample_explanation": "最长为 \"()\" 长度 2"},
      {"input_text": ")()())\n", "output_text": "4\n", "is_sample": true, "sample_explanation": "\"()()\" 长度 4"},
      {"input_text": "\n", "output_text": "0\n", "is_sample": false},
      {"input_text": ")\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "()()()\n", "output_text": "6\n", "is_sample": false},
      {"input_text": "()(())\n", "output_text": "6\n", "is_sample": false},
      {"input_text": "())((())\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "((())())\n", "output_text": "8\n", "is_sample": false}
    ]
  },
  {
    "slug": "search-in-rotated-sorted-array",
    "title": "搜索旋转排序数组",
    "difficulty": "MEDIUM",
    "tags": ["数组", "二分查找"],
    "content": "给定经过旋转的升序数组 nums 和目标值 target（无重复），在 O(log n) 时间内返回 target 下标，未找到返回 -1。",
    "input_description": "第一行整数 n，第二行 n 个整数（旋转后的升序数组），第三行整数 target。",
    "output_description": "输出目标下标或 -1，行尾换行。",
    "constraints": "$1 \\le n \\le 10^{5}$，元素与 target 绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "7\n4 5 6 7 0 1 2\n0\n", "output_text": "4\n", "is_sample": true, "sample_explanation": "旋转后 0 在索引 4"},
      {"input_text": "7\n4 5 6 7 0 1 2\n3\n", "output_text": "-1\n", "is_sample": true, "sample_explanation": "数组中不存在 3 返回 -1"},
      {"input_text": "1\n1\n0\n", "output_text": "-1\n", "is_sample": false},
      {"input_text": "2\n5 1\n5\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "2\n5 1\n1\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "9\n9 10 11 12 1 2 3 4 5\n4\n", "output_text": "7\n", "is_sample": false},
      {"input_text": "6\n6 7 8 1 2 3\n8\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "6\n6 7 8 1 2 3\n5\n", "output_text": "-1\n", "is_sample": false}
    ]
  },
  {
    "slug": "find-first-and-last-position-of-element-in-sorted-array",
    "title": "在排序数组中查找元素的第一个和最后一个位置",
    "difficulty": "MEDIUM",
    "tags": ["数组", "二分查找"],
    "content": "给定升序数组 nums 和目标值 target，找出 target 在数组中的起始和结束位置。若不存在，返回 -1 -1。",
    "input_description": "第一行整数 n，第二行 n 个升序整数，第三行整数 target。",
    "output_description": "输出两个整数 l r，空格分隔；不存在输出 -1 -1。",
    "constraints": "$1 \\le n \\le 10^{5}$，元素绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "6\n5 7 7 8 8 10\n8\n", "output_text": "3 4\n", "is_sample": true, "sample_explanation": "8 出现于索引 3..4"},
      {"input_text": "6\n5 7 7 8 8 10\n6\n", "output_text": "-1 -1\n", "is_sample": true, "sample_explanation": "不存在目标值返回 -1 -1"},
      {"input_text": "1\n1\n1\n", "output_text": "0 0\n", "is_sample": false},
      {"input_text": "5\n1 2 3 3 3\n3\n", "output_text": "2 4\n", "is_sample": false},
      {"input_text": "5\n2 2 2 2 2\n2\n", "output_text": "0 4\n", "is_sample": false},
      {"input_text": "5\n1 3 5 7 9\n4\n", "output_text": "-1 -1\n", "is_sample": false},
      {"input_text": "7\n1 2 3 3 3 4 5\n2\n", "output_text": "1 1\n", "is_sample": false},
      {"input_text": "7\n1 2 3 3 3 4 5\n5\n", "output_text": "6 6\n", "is_sample": false}
    ]
  },
  {
    "slug": "search-insert-position",
    "title": "搜索插入位置",
    "difficulty": "EASY",
    "tags": ["数组", "二分查找"],
    "content": "给定升序数组和目标值，若存在返回下标，否则返回按顺序插入的位置下标。",
    "input_description": "第一行整数 n，第二行 n 个升序整数，第三行整数 target。",
    "output_description": "输出一个整数表示位置。",
    "constraints": "$0 \\le n \\le 10^{5}$，元素绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "4\n1 3 5 6\n5\n", "output_text": "2\n", "is_sample": true, "sample_explanation": "目标 5 在索引 2"},
      {"input_text": "4\n1 3 5 6\n2\n", "output_text": "1\n", "is_sample": true, "sample_explanation": "2 应插入索引 1"},
      {"input_text": "4\n1 3 5 6\n7\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "4\n1 3 5 6\n0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "1\n1\n1\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "1\n1\n0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "1\n1\n2\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "5\n1 2 4 6 8\n3\n", "output_text": "2\n", "is_sample": false}
    ]
  },
  {
    "slug": "combination-sum",
    "title": "组合总和",
    "difficulty": "MEDIUM",
    "tags": ["回溯", "数组"],
    "content": "给定候选数字数组（可重复使用）和目标值 target，找出所有和为 target 的组合。组合内数字按非降序输出，多个组合按字典序逐行输出；若无组合输出 \"NONE\"。",
    "input_description": "第一行整数 n，第二行 n 个正整数，第三行整数 target。",
    "output_description": "每行一个组合，数字间空格分隔；若不存在输出 \"NONE\"。",
    "constraints": "$1 \\le n \\le 30,\\ 1 \\le candidates[i], target \\le 10^{9}$",
    "testcases": [
      {"input_text": "4\n2 3 6 7\n7\n", "output_text": "2 2 3\n7\n", "is_sample": true},
      {"input_text": "3\n2 3 5\n8\n", "output_text": "2 2 2 2\n2 3 3\n3 5\n", "is_sample": true},
      {"input_text": "3\n2 3 5\n1\n", "output_text": "NONE\n", "is_sample": false},
      {"input_text": "2\n1 2\n4\n", "output_text": "1 1 1 1\n1 1 2\n2 2\n", "is_sample": false},
      {"input_text": "1\n9\n18\n", "output_text": "9 9\n", "is_sample": false},
      {"input_text": "4\n2 3 5 7\n9\n", "output_text": "2 2 2 3\n2 2 5\n2 7\n", "is_sample": false},
      {"input_text": "3\n8 10 6\n16\n", "output_text": "8 8\n", "is_sample": false},
      {"input_text": "3\n5 10 25\n30\n", "output_text": "5 5 5 5 5 5\n5 5 10 10\n5 25\n", "is_sample": false}
    ]
  },
  {
    "slug": "trapping-rain-water",
    "title": "接雨水",
    "difficulty": "HARD",
    "tags": ["单调栈", "双指针"],
    "content": "给定非负整数数组表示柱状图高度，计算下雨后能接多少水。",
    "input_description": "第一行整数 n，第二行 n 个非负整数。",
    "output_description": "输出总接水量，行尾换行。",
    "constraints": "$1 \\le n \\le 10^{5},\\ 0 \\le height[i] \\le 10^{9}$",
    "testcases": [
      {"input_text": "12\n0 1 0 2 1 0 1 3 2 1 2 1\n", "output_text": "6\n", "is_sample": true, "sample_explanation": "经典示例，双指针/单调栈可得蓄水总量 6"},
      {"input_text": "3\n0 1 0\n", "output_text": "1\n", "is_sample": true, "sample_explanation": "中间形成一个高度 1 的坑位，面积 1"},
      {"input_text": "5\n2 0 2 0 2\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "5\n3 0 2 0 4\n", "output_text": "7\n", "is_sample": false},
      {"input_text": "4\n4 2 0 3\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "1\n5\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "6\n0 0 0 0 0 0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "6\n5 4 3 2 1 0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "7\n0 2 0 2 0 2 0\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "8\n5 2 1 2 1 5 1 2\n", "output_text": "14\n", "is_sample": false}
    ]
  },
  {
    "slug": "permutations",
    "title": "全排列",
    "difficulty": "MEDIUM",
    "tags": ["回溯"],
    "content": "给定一组互不相同的整数，返回它们所有可能的全排列。输出按字典序，每行一个排列。",
    "input_description": "第一行整数 n，第二行 n 个互不相同的整数。",
    "output_description": "每行一个排列，元素间空格分隔；按字典序输出。",
    "constraints": "$1 \\le n \\le 9$，元素绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "3\n1 2 3\n", "output_text": "1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1\n", "is_sample": true},
      {"input_text": "1\n5\n", "output_text": "5\n", "is_sample": true},
      {"input_text": "2\n0 1\n", "output_text": "0 1\n1 0\n", "is_sample": false},
      {"input_text": "3\n-1 0 1\n", "output_text": "-1 0 1\n-1 1 0\n0 -1 1\n0 1 -1\n1 -1 0\n1 0 -1\n", "is_sample": false},
      {"input_text": "4\n1 2 3 4\n", "output_text": "1 2 3 4\n1 2 4 3\n1 3 2 4\n...", "is_sample": false}
    ]
  },
  {
    "slug": "rotate-image",
    "title": "旋转图像",
    "difficulty": "MEDIUM",
    "tags": ["数组", "原地操作"],
    "content": "给定一个 n×n 的矩阵，原地顺时针旋转 90 度。输入输出均为矩阵，旋转后输出每行。",
    "input_description": "第一行整数 n；接下来 n 行，每行 n 个整数表示矩阵。",
    "output_description": "输出旋转后的矩阵，每行 n 个整数，行尾换行。",
    "constraints": "$1 \\le n \\le 200$，元素绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "3\n1 2 3\n4 5 6\n7 8 9\n", "output_text": "7 4 1\n8 5 2\n9 6 3\n", "is_sample": true},
      {"input_text": "2\n1 2\n3 4\n", "output_text": "3 1\n4 2\n", "is_sample": true},
      {"input_text": "1\n5\n", "output_text": "5\n", "is_sample": false},
      {"input_text": "4\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n", "output_text": "13 9 5 1\n14 10 6 2\n15 11 7 3\n16 12 8 4\n", "is_sample": false},
      {"input_text": "3\n1 1 1\n1 1 1\n1 1 1\n", "output_text": "1 1 1\n1 1 1\n1 1 1\n", "is_sample": false},
      {"input_text": "3\n0 -1 -2\n-3 -4 -5\n-6 -7 -8\n", "output_text": "-6 -3 0\n-7 -4 -1\n-8 -5 -2\n", "is_sample": false}
    ]
  },
  {
    "slug": "group-anagrams",
    "title": "字母异位词分组",
    "difficulty": "MEDIUM",
    "tags": ["哈希表", "字符串"],
    "content": "给定字符串数组，将字母异位词分到同一组。判断异位词可通过排序后的键或计数向量。输出时，每组内部单词按字典序排序，组之间按组首元素字典序排序输出，便于评测。",
    "input_description": "第一行整数 n，第二行 n 个字符串。",
    "output_description": "按要求输出分组结果，每组一行，组内单词空格分隔。",
    "constraints": "$1 \\le n \\le 10^{4}$，单词长度不超过 100。",
    "testcases": [
      {"input_text": "6\neat tea tan ate nat bat\n", "output_text": "ate eat tea\nbat\nnat tan\n", "is_sample": true, "sample_explanation": "\"eat/tea/ate\" 为一组，\"tan/nat\" 一组，\"bat\" 单独一组"},
      {"input_text": "3\na a a\n", "output_text": "a a a\n", "is_sample": true, "sample_explanation": "全部相同，单组输出"},
      {"input_text": "4\nabc bca cab cba\n", "output_text": "abc bca cab cba\n", "is_sample": false},
      {"input_text": "5\nbddb dbdb bddb ccc abc\n", "output_text": "abc\nbddb bddb dbdb\nccc\n", "is_sample": false},
      {"input_text": "3\nabc def ghi\n", "output_text": "abc\ndef\nghi\n", "is_sample": false},
      {"input_text": "5\nzzz zzz zz zz z\n", "output_text": "z\nzz\nzzz zzz\n", "is_sample": false}
    ]
  },
  {
    "slug": "jump-game",
    "title": "跳跃游戏",
    "difficulty": "MEDIUM",
    "tags": ["贪心", "数组"],
    "content": "给定非负整数数组，每个元素代表从该位置最多能跳的步数。判断能否从下标 0 跳到最后一个下标。常用贪心维护当前能到的最远位置。",
    "input_description": "第一行整数 n，第二行 n 个非负整数。",
    "output_description": "能到达输出 \"true\"，否则输出 \"false\"。",
    "constraints": "$1 \\le n \\le 10^{5}$，元素不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "5\n2 3 1 1 4\n", "output_text": "true\n", "is_sample": true, "sample_explanation": "最远可达末尾，存在路径"},
      {"input_text": "5\n3 2 1 0 4\n", "output_text": "false\n", "is_sample": true, "sample_explanation": "跳到 0 后被卡住，无法到达末尾"},
      {"input_text": "1\n0\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "2\n0 1\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "4\n2 0 0 0\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "6\n1 1 1 1 1 1\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "6\n5 4 3 2 1 0\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "6\n1 0 2 0 0 1\n", "output_text": "false\n", "is_sample": false}
    ]
  },
  {
    "slug": "merge-intervals",
    "title": "合并区间",
    "difficulty": "MEDIUM",
    "tags": ["排序", "数组"],
    "content": "给定若干闭区间，合并所有重叠区间，输出合并后区间集合，按起点升序。可先按起点排序再线性扫描。",
    "input_description": "第一行整数 n，接下来 n 行每行两个整数 l r 表示一个区间。",
    "output_description": "合并后的区间逐行输出 \"l r\"。",
    "constraints": "$1 \\le n \\le 10^{5}$，区间端点绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "4\n1 3\n2 6\n8 10\n15 18\n", "output_text": "1 6\n8 10\n15 18\n", "is_sample": true, "sample_explanation": "1-3 与 2-6 重叠合并为 1-6"},
      {"input_text": "2\n1 4\n4 5\n", "output_text": "1 5\n", "is_sample": true, "sample_explanation": "端点重合也视为重叠，合并为 1-5"},
      {"input_text": "1\n1 5\n", "output_text": "1 5\n", "is_sample": false},
      {"input_text": "3\n1 2\n3 4\n5 6\n", "output_text": "1 2\n3 4\n5 6\n", "is_sample": false},
      {"input_text": "3\n1 10\n2 3\n4 8\n", "output_text": "1 10\n", "is_sample": false},
      {"input_text": "5\n-5 -3\n-4 0\n1 2\n2 3\n3 4\n", "output_text": "-5 0\n1 4\n", "is_sample": false},
      {"input_text": "4\n0 0\n0 0\n1 1\n2 2\n", "output_text": "0 0\n1 1\n2 2\n", "is_sample": false}
    ]
  },
  {
    "slug": "unique-paths",
    "title": "不同路径",
    "difficulty": "MEDIUM",
    "tags": ["动态规划", "组合数学"],
    "content": "m×n 网格，机器人从左上角出发，每次只能向右或向下，问到达右下角共有多少条不同路径。可用组合公式或 DP 计算。",
    "input_description": "一行两个整数 m n。",
    "output_description": "输出路径数（整数）。",
    "constraints": "$1 \\le m,n \\le 100$",
    "testcases": [
      {"input_text": "3 7\n", "output_text": "28\n", "is_sample": true, "sample_explanation": "等价组合 C(8,2)=28"},
      {"input_text": "3 2\n", "output_text": "3\n", "is_sample": true, "sample_explanation": "路径 \"RRD\"、\"RDR\"、\"DRR\" 共 3 条"},
      {"input_text": "1 1\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "2 2\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "7 3\n", "output_text": "28\n", "is_sample": false},
      {"input_text": "10 10\n", "output_text": "48620\n", "is_sample": false},
      {"input_text": "15 1\n", "output_text": "1\n", "is_sample": false}
    ]
  },
  {
    "slug": "minimum-path-sum",
    "title": "最小路径和",
    "difficulty": "MEDIUM",
    "tags": ["动态规划", "网格"],
    "content": "给定非负权值网格，从左上到右下，只能向右或向下，求路径的最小权值和。典型网格 DP。",
    "input_description": "第一行两个整数 m n；接下来 m 行，每行 n 个非负整数。",
    "output_description": "输出最小路径和，行尾换行。",
    "constraints": "$1 \\le m,n \\le 200$，单元格值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "3 3\n1 3 1\n1 5 1\n4 2 1\n", "output_text": "7\n", "is_sample": true, "sample_explanation": "最优路径 1→3→1→1→1，总和 7"},
      {"input_text": "1 2\n1 2\n", "output_text": "3\n", "is_sample": true, "sample_explanation": "唯一可行路线，代价 3"},
      {"input_text": "2 2\n1 1\n1 1\n", "output_text": "3\n", "is_sample": false},
      {"input_text": "2 3\n1 2 3\n4 5 6\n", "output_text": "12\n", "is_sample": false},
      {"input_text": "3 2\n1 2\n1 1\n4 2\n", "output_text": "6\n", "is_sample": false},
      {"input_text": "1 1\n0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "3 3\n5 4 2\n1 9 1\n0 2 1\n", "output_text": "9\n", "is_sample": false}
    ]
  },
  {
    "slug": "edit-distance",
    "title": "编辑距离",
    "difficulty": "HARD",
    "tags": ["动态规划", "字符串"],
    "content": "给定两个字符串，允许插入、删除、替换字符，求将一个变成另一个的最少操作次数（经典 Levenshtein 距离）。可用 DP，转移考虑三种操作。",
    "input_description": "第一行字符串 word1，第二行字符串 word2。",
    "output_description": "输出最少操作数，行尾换行。",
    "constraints": "$0 \\le |word1|,|word2| \\le 500$",
    "testcases": [
      {"input_text": "horse\nros\n", "output_text": "3\n", "is_sample": true, "sample_explanation": "horse→rorse(替换)→rose(删除)→ros(删除) 共 3 步"},
      {"input_text": "intention\nexecution\n", "output_text": "5\n", "is_sample": true, "sample_explanation": "经典示例，最少 5 步"},
      {"input_text": "a\nb\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "\n\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "abc\nabc\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "kitten\nsitting\n", "output_text": "3\n", "is_sample": false},
      {"input_text": "abcdef\nazced\n", "output_text": "3\n", "is_sample": false},
      {"input_text": "pneumonoultramicroscopicsilicovolcanoconiosis\nultramicroscopicsilicovolcanoconiosis\n", "output_text": "11\n", "is_sample": false}
    ]
  },
  {
    "slug": "sort-colors",
    "title": "颜色分类",
    "difficulty": "MEDIUM",
    "tags": ["双指针", "排序"],
    "content": "数组仅包含 0、1、2，要求原地排序为 0,1,2（荷兰国旗问题），需 O(n) 单趟。",
    "input_description": "第一行整数 n，第二行 n 个整数（仅 0/1/2）。",
    "output_description": "输出排序后的数组，空格分隔。",
    "constraints": "$1 \\le n \\le 10^{5}$",
    "testcases": [
      {"input_text": "6\n2 0 2 1 1 0\n", "output_text": "0 0 1 1 2 2\n", "is_sample": true, "sample_explanation": "三指针分区后 0/1/2 有序"},
      {"input_text": "3\n2 0 1\n", "output_text": "0 1 2\n", "is_sample": true, "sample_explanation": "最小长度示例"},
      {"input_text": "5\n0 0 0 0 0\n", "output_text": "0 0 0 0 0\n", "is_sample": false},
      {"input_text": "5\n2 2 2 2 2\n", "output_text": "2 2 2 2 2\n", "is_sample": false},
      {"input_text": "5\n1 1 1 1 1\n", "output_text": "1 1 1 1 1\n", "is_sample": false},
      {"input_text": "7\n2 1 0 2 1 0 1\n", "output_text": "0 0 1 1 1 2 2\n", "is_sample": false}
    ]
  },
  {
    "slug": "minimum-window-substring",
    "title": "最小覆盖子串",
    "difficulty": "HARD",
    "tags": ["滑动窗口", "字符串"],
    "content": "给定字符串 s 和 t，求 s 中包含 t 所有字符的最短子串（大小写敏感，可含重复），若不存在返回空串。典型滑动窗口，需要维护计数与覆盖度。",
    "input_description": "第一行字符串 s，第二行字符串 t。",
    "output_description": "输出最小覆盖子串，若不存在输出空行。",
    "constraints": "$1 \\le |s|,|t| \\le 10^{5}$",
    "testcases": [
      {"input_text": "ADOBECODEBANC\nABC\n", "output_text": "BANC\n", "is_sample": true, "sample_explanation": "最短覆盖 ABC 的子串为 \"BANC\""},
      {"input_text": "a\nb\n", "output_text": "\n", "is_sample": true, "sample_explanation": "缺少字符 b，无解返回空"},
      {"input_text": "a\na\n", "output_text": "a\n", "is_sample": false},
      {"input_text": "aa\naa\n", "output_text": "aa\n", "is_sample": false},
      {"input_text": "aa\nab\n", "output_text": "\n", "is_sample": false},
      {"input_text": "ab\nb\n", "output_text": "b\n", "is_sample": false},
      {"input_text": "thisisateststring\ntist\n", "output_text": "tstri\n", "is_sample": false}
    ]
  },
  {
    "slug": "subsets",
    "title": "子集",
    "difficulty": "MEDIUM",
    "tags": ["回溯", "位运算"],
    "content": "给定一组不重复的整数，返回所有子集（幂集）。可用回溯/位运算生成。输出按子集长度升序，再按字典序，空集也需输出。",
    "input_description": "第一行整数 n，第二行 n 个互不相同的整数。",
    "output_description": "每行一个子集，元素空格分隔；空集输出空行。",
    "constraints": "$1 \\le n \\le 15$",
    "testcases": [
      {"input_text": "3\n1 2 3\n", "output_text": "\n1\n2\n3\n1 2\n1 3\n2 3\n1 2 3\n", "is_sample": true, "sample_explanation": "共 2^3=8 个子集，含空集"},
      {"input_text": "1\n5\n", "output_text": "\n5\n", "is_sample": true, "sample_explanation": "元素只有 5，对应空集和 {5}"},
      {"input_text": "2\n0 1\n", "output_text": "\n0\n1\n0 1\n", "is_sample": false},
      {"input_text": "3\n-1 0 1\n", "output_text": "\n-1\n0\n1\n-1 0\n-1 1\n0 1\n-1 0 1\n", "is_sample": false}
    ]
  },
  {
    "slug": "word-search",
    "title": "单词搜索",
    "difficulty": "MEDIUM",
    "tags": ["回溯", "网格"],
    "content": "给定字符网格和单词，判断是否存在一条路径可拼出该单词。路径从任意格开始，按上下左右相邻移动，同一格只能使用一次。典型回溯 + 剪枝。",
    "input_description": "第一行两个整数 m n；接下来 m 行，每行 n 个字符（不含空格）；最后一行为目标单词。",
    "output_description": "若可以拼出输出 \"true\"，否则输出 \"false\"。",
    "constraints": "$1 \\le m,n \\le 6$，单词长度不超过 15。",
    "testcases": [
      {"input_text": "3 4\nABCE\nSFCS\nADEE\nABCCED\n", "output_text": "true\n", "is_sample": true},
      {"input_text": "3 4\nABCE\nSFCS\nADEE\nSEE\n", "output_text": "true\n", "is_sample": true},
      {"input_text": "3 4\nABCE\nSFCS\nADEE\nABCB\n", "output_text": "false\n", "is_sample": true},
      {"input_text": "1 1\nA\nA\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "1 2\nAB\nBA\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "2 2\nAA\nAA\nAAAA\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "2 3\nABC\nDEF\nADB\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "2 3\nCAA\nAAA\nAAA\n", "output_text": "true\n", "is_sample": false}
    ]
  },
  {
    "slug": "largest-rectangle-in-histogram",
    "title": "柱状图中最大的矩形",
    "difficulty": "HARD",
    "tags": ["单调栈", "数组"],
    "content": "给定非负整数数组表示柱状图高度，求能勾勒出的最大矩形面积。",
    "input_description": "第一行整数 n，第二行 n 个非负整数表示高度。",
    "output_description": "输出最大面积整数，行尾换行。",
    "constraints": "$1 \\le n \\le 10^{5}$，高度不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "6\n2 1 5 6 2 3\n", "output_text": "10\n", "is_sample": true},
      {"input_text": "1\n2\n", "output_text": "2\n", "is_sample": true},
      {"input_text": "3\n5 5 5\n", "output_text": "15\n", "is_sample": false},
      {"input_text": "5\n1 2 3 4 5\n", "output_text": "9\n", "is_sample": false},
      {"input_text": "5\n5 4 3 2 1\n", "output_text": "9\n", "is_sample": false},
      {"input_text": "3\n0 0 0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "2\n2 4\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "6\n4 2 0 3 2 5\n", "output_text": "6\n", "is_sample": false},
      {"input_text": "1\n100000\n", "output_text": "100000\n", "is_sample": false}
    ]
  },
  {
    "slug": "maximal-rectangle",
    "title": "最大矩形",
    "difficulty": "HARD",
    "tags": ["单调栈", "动态规划"],
    "content": "给定仅包含 0 和 1 的矩阵，求只含 1 的最大矩形面积。",
    "input_description": "第一行两个整数 m n；接下来 m 行，每行一个由 0/1 组成且长度为 n 的字符串。",
    "output_description": "输出最大全 1 矩形的面积。",
    "constraints": "$1 \\le m,n \\le 200$",
    "testcases": [
      {"input_text": "4 5\n10100\n10111\n11111\n10010\n", "output_text": "6\n", "is_sample": true},
      {"input_text": "1 1\n1\n", "output_text": "1\n", "is_sample": true},
      {"input_text": "1 4\n0000\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "2 2\n11\n11\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "3 3\n101\n111\n111\n", "output_text": "6\n", "is_sample": false},
      {"input_text": "3 4\n1111\n1111\n1111\n", "output_text": "12\n", "is_sample": false},
      {"input_text": "2 3\n010\n010\n", "output_text": "2\n", "is_sample": false}
    ]
  },
  {
    "slug": "binary-tree-inorder-traversal",
    "title": "二叉树的中序遍历",
    "difficulty": "EASY",
    "tags": ["树", "栈"],
    "content": "给定二叉树，返回中序遍历序列。输入使用层序数组表示，null 表示空指针。",
    "input_description": "第一行整数 m，表示层序数组长度；第二行 m 个字符串（整数或 null）。",
    "output_description": "输出中序遍历的节点值，空格分隔；空树输出空行。",
    "constraints": "$0 \\le m \\le 2000$，节点值绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "7\n1 2 3 null null 4 5\n", "output_text": "2 1 4 3 5\n", "is_sample": true},
      {"input_text": "0\n\n", "output_text": "\n", "is_sample": true},
      {"input_text": "1\n1\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "3\n1 null 2\n", "output_text": "1 2\n", "is_sample": false},
      {"input_text": "5\n2 1 3 null null\n", "output_text": "1 2 3\n", "is_sample": false},
      {"input_text": "7\n5 3 7 2 4 6 8\n", "output_text": "2 3 4 5 6 7 8\n", "is_sample": false}
    ]
  },
  {
    "slug": "unique-binary-search-trees",
    "title": "不同的二叉搜索树",
    "difficulty": "MEDIUM",
    "tags": ["动态规划", "数学"],
    "content": "给定 n，问用值 1..n 能构成多少种不同结构的二叉搜索树。",
    "input_description": "一行整数 n。",
    "output_description": "输出方案数（卡特兰数），行尾换行。",
    "constraints": "$0 \\le n \\le 19$",
    "testcases": [
      {"input_text": "3\n", "output_text": "5\n", "is_sample": true},
      {"input_text": "1\n", "output_text": "1\n", "is_sample": true},
      {"input_text": "2\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "0\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "5\n", "output_text": "42\n", "is_sample": false},
      {"input_text": "8\n", "output_text": "1430\n", "is_sample": false},
      {"input_text": "10\n", "output_text": "16796\n", "is_sample": false}
    ]
  },
  {
    "slug": "validate-binary-search-tree",
    "title": "验证二叉搜索树",
    "difficulty": "MEDIUM",
    "tags": ["树", "递归"],
    "content": "判断给定二叉树是否为合法二叉搜索树。输入为层序数组，null 表示空指针。",
    "input_description": "第一行整数 m；第二行 m 个字符串（整数或 null）。",
    "output_description": "若是合法 BST 输出 \"true\"，否则输出 \"false\"。",
    "constraints": "$0 \\le m \\le 2000$，节点值绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "3\n2 1 3\n", "output_text": "true\n", "is_sample": true},
      {"input_text": "5\n5 1 4 null null 3 6\n", "output_text": "false\n", "is_sample": true},
      {"input_text": "1\n1\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "3\n2 2 2\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "7\n10 5 15 null null 6 20\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "7\n10 5 15 null null 11 20\n", "output_text": "true\n", "is_sample": false}
    ]
  },
  {
    "slug": "same-tree",
    "title": "相同的树",
    "difficulty": "EASY",
    "tags": ["树", "递归"],
    "content": "判断两棵二叉树是否在结构和节点值上完全相同。输入为两棵树的层序序列。",
    "input_description": "第一行整数 m1，第二行 m1 个字符串（整数或 null）表示树 A；第三行整数 m2，第四行 m2 个字符串表示树 B。",
    "output_description": "相同输出 \"true\"，否则输出 \"false\"。",
    "constraints": "$0 \\le m1,m2 \\le 2000$。",
    "testcases": [
      {"input_text": "3\n1 2 3\n3\n1 2 3\n", "output_text": "true\n", "is_sample": true},
      {"input_text": "3\n1 2 1\n3\n1 1 2\n", "output_text": "false\n", "is_sample": true},
      {"input_text": "0\n\n0\n\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "1\n1\n1\n2\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "5\n1 2 3 null null\n5\n1 2 3 null null\n", "output_text": "true\n", "is_sample": false}
    ]
  },
  {
    "slug": "symmetric-tree",
    "title": "对称二叉树",
    "difficulty": "EASY",
    "tags": ["树", "递归", "BFS"],
    "content": "判断二叉树是否关于根节点左右对称。输入层序序列，null 表示空。",
    "input_description": "第一行整数 m，第二行 m 个字符串（整数或 null）。",
    "output_description": "对称输出 \"true\"，否则输出 \"false\"。",
    "constraints": "$0 \\le m \\le 2000$。",
    "testcases": [
      {"input_text": "7\n1 2 2 3 4 4 3\n", "output_text": "true\n", "is_sample": true},
      {"input_text": "5\n1 2 2 null 3 null 3\n", "output_text": "false\n", "is_sample": true},
      {"input_text": "1\n1\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "3\n1 2 2\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "3\n1 2 3\n", "output_text": "false\n", "is_sample": false}
    ]
  },
  {
    "slug": "binary-tree-level-order-traversal",
    "title": "二叉树的层序遍历",
    "difficulty": "MEDIUM",
    "tags": ["树", "BFS"],
    "content": "返回二叉树的层序遍历结果。输入层序数组表示树，null 表示空指针。可用队列按层遍历并输出每层节点值。",
    "input_description": "第一行整数 m；第二行 m 个字符串（整数或 null）。",
    "output_description": "按层输出节点值，每层一行，节点间空格分隔；空树输出空行。",
    "constraints": "$0 \\le m \\le 2000$。",
    "testcases": [
      {"input_text": "7\n3 9 20 null null 15 7\n", "output_text": "3\n9 20\n15 7\n", "is_sample": true, "sample_explanation": "根 3，在第二层有 9 和 20，第三层 15 和 7"},
      {"input_text": "0\n\n", "output_text": "\n", "is_sample": true},
      {"input_text": "1\n1\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "5\n1 2 3 4 5\n", "output_text": "1\n2 3\n4 5\n", "is_sample": false},
      {"input_text": "3\n1 null 2\n", "output_text": "1\n2\n", "is_sample": false}
    ]
  },
  {
    "slug": "maximum-depth-of-binary-tree",
    "title": "二叉树的最大深度",
    "difficulty": "EASY",
    "tags": ["树", "DFS"],
    "content": "给定二叉树，返回从根到最深叶子的节点数（深度）。可用 DFS 或 BFS。",
    "input_description": "第一行整数 m；第二行 m 个字符串（整数或 null）为层序序列。",
    "output_description": "输出最大深度整数，空树输出 0。",
    "constraints": "$0 \\le m \\le 2000$。",
    "testcases": [
      {"input_text": "7\n3 9 20 null null 15 7\n", "output_text": "3\n", "is_sample": true},
      {"input_text": "1\n1\n", "output_text": "1\n", "is_sample": true},
      {"input_text": "0\n\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "5\n1 2 3 4 5\n", "output_text": "3\n", "is_sample": false},
      {"input_text": "3\n1 null 2\n", "output_text": "2\n", "is_sample": false}
    ]
  },
  {
    "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "title": "从前序与中序遍历序列构造二叉树",
    "difficulty": "MEDIUM",
    "tags": ["树", "分治"],
    "content": "给定前序和中序遍历结果，重建二叉树并输出其层序序列（null 表示空）。需自行构建树并做层序打印，注意值唯一。",
    "input_description": "第一行整数 n；第二行 n 个整数为前序遍历；第三行 n 个整数为中序遍历。",
    "output_description": "输出重建后树的层序序列，使用空格分隔，空指针用 null 表示，行尾换行。",
    "constraints": "$0 \\le n \\le 2000$。",
    "testcases": [
      {"input_text": "7\n3 9 20 15 7 1 2\n9 3 15 20 7 2 1\n", "output_text": "3 9 20 null null 15 7 null null null null 1 2\n", "is_sample": true},
      {"input_text": "0\n\n\n", "output_text": "\n", "is_sample": true},
      {"input_text": "3\n1 2 3\n2 1 3\n", "output_text": "1 2 3\n", "is_sample": false},
      {"input_text": "3\n1 2 3\n3 2 1\n", "output_text": "1 2 null 3\n", "is_sample": false},
      {"input_text": "4\n1 2 3 4\n2 1 4 3\n", "output_text": "1 2 3 null null 4\n", "is_sample": false}
    ]
  },
  {
    "slug": "flatten-binary-tree-to-linked-list",
    "title": "二叉树展开为链表",
    "difficulty": "MEDIUM",
    "tags": ["树", "DFS"],
    "content": "将二叉树按先序遍历顺序就地展开为单链表（仅右指针），输出展开后的节点值序列。需原地修改指针。",
    "input_description": "第一行整数 m；第二行 m 个字符串（整数或 null）为层序序列。",
    "output_description": "输出展开后的节点值，空格分隔；空树输出空行。",
    "constraints": "$0 \\le m \\le 2000$。",
    "testcases": [
      {"input_text": "7\n1 2 5 3 4 null 6\n", "output_text": "1 2 3 4 5 6\n", "is_sample": true},
      {"input_text": "0\n\n", "output_text": "\n", "is_sample": true},
      {"input_text": "1\n1\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "3\n1 2 3\n", "output_text": "1 2 3\n", "is_sample": false},
      {"input_text": "5\n1 null 2 null 3\n", "output_text": "1 2 3\n", "is_sample": false}
    ]
  },
  {
    "slug": "best-time-to-buy-and-sell-stock",
    "title": "买卖股票的最佳时机",
    "difficulty": "EASY",
    "tags": ["数组", "贪心"],
    "content": "给定每天的股价，只允许一次买入一次卖出，求最大利润（可为 0）。",
    "input_description": "第一行整数 n，第二行 n 个整数表示股价。",
    "output_description": "输出最大利润整数，行尾换行。",
    "constraints": "$1 \\le n \\le 10^{5}$，股价不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "6\n7 1 5 3 6 4\n", "output_text": "5\n", "is_sample": true},
      {"input_text": "5\n7 6 4 3 1\n", "output_text": "0\n", "is_sample": true},
      {"input_text": "2\n1 2\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "2\n2 1\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "3\n2 4 1\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "5\n3 3 3 3 3\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "6\n1 2 3 4 5 6\n", "output_text": "5\n", "is_sample": false}
    ]
  },
  {
    "slug": "binary-tree-maximum-path-sum",
    "title": "二叉树中的最大路径和",
    "difficulty": "HARD",
    "tags": ["树", "DFS"],
    "content": "给定非空二叉树，返回任意两节点间路径（必须连通且可只包含单节点）的最大路径和。",
    "input_description": "第一行整数 m；第二行 m 个字符串为层序序列（整数或 null）。",
    "output_description": "输出最大路径和整数，行尾换行。",
    "constraints": "$1 \\le m \\le 2000$，节点值绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "7\n1 2 3 null null 4 5\n", "output_text": "12\n", "is_sample": true},
      {"input_text": "3\n-10 9 20 null null 15 7\n", "output_text": "42\n", "is_sample": true},
      {"input_text": "1\n-3\n", "output_text": "-3\n", "is_sample": false},
      {"input_text": "3\n2 -1 -2\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "5\n5 4 8 11 null 13 4 7 2 null null null 1\n", "output_text": "48\n", "is_sample": false}
    ]
  },
  {
    "slug": "longest-consecutive-sequence",
    "title": "最长连续序列",
    "difficulty": "MEDIUM",
    "tags": ["哈希表", "数组"],
    "content": "给定未排序整数数组，找出最长连续元素序列的长度，要求 O(n) 时间。常用哈希集合判断序列起点（前驱不存在）再线性扩展。",
    "input_description": "第一行整数 n，第二行 n 个整数。",
    "output_description": "输出最长连续序列的长度，行尾换行。",
    "constraints": "$0 \\le n \\le 10^{5}$，元素绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "6\n100 4 200 1 3 2\n", "output_text": "4\n", "is_sample": true, "sample_explanation": "最长连续序列为 1,2,3,4 长度 4"},
      {"input_text": "0\n\n", "output_text": "0\n", "is_sample": true, "sample_explanation": "空数组返回 0"},
      {"input_text": "1\n1\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "5\n9 1 4 7 3\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "8\n0 -1 1 2 -2 3 4 5\n", "output_text": "6\n", "is_sample": false},
      {"input_text": "5\n10 5 6 7 20\n", "output_text": "3\n", "is_sample": false}
    ]
  },
  {
    "slug": "single-number",
    "title": "只出现一次的数字",
    "difficulty": "EASY",
    "tags": ["位运算", "哈希表"],
    "content": "数组中其他元素都出现两次，只有一个元素出现一次，找出该元素。",
    "input_description": "第一行整数 n，第二行 n 个整数。",
    "output_description": "输出只出现一次的数字，行尾换行。",
    "constraints": "$1 \\le n \\le 3\\times10^{5}$，保证答案存在且唯一。",
    "testcases": [
      {"input_text": "3\n2 2 1\n", "output_text": "1\n", "is_sample": true},
      {"input_text": "5\n4 1 2 1 2\n", "output_text": "4\n", "is_sample": true},
      {"input_text": "1\n7\n", "output_text": "7\n", "is_sample": false},
      {"input_text": "7\n0 0 1 1 2 2 3\n", "output_text": "3\n", "is_sample": false},
      {"input_text": "5\n-1 -1 -2 -2 -3\n", "output_text": "-3\n", "is_sample": false},
      {"input_text": "5\n1000000000 2 2 3 3\n", "output_text": "1000000000\n", "is_sample": false}
    ]
  },
  {
    "slug": "word-break",
    "title": "单词拆分",
    "difficulty": "MEDIUM",
    "tags": ["动态规划", "字符串"],
    "content": "给定字符串 s 和字典 wordDict，判断 s 能否拆分成若干字典单词。典型解法为 DP，dp[i] 表示前 i 位可否拆分。",
    "input_description": "第一行字符串 s；第二行整数 m；第三行 m 个字符串为字典。",
    "output_description": "能拆分输出 \"true\"，否则输出 \"false\"。",
    "constraints": "$1 \\le |s| \\le 10^{5}$，字典单词总长度不超过 $10^{5}$。",
    "testcases": [
      {"input_text": "leetcode\n2\nleet code\n", "output_text": "true\n", "is_sample": true, "sample_explanation": "\"leet\" + \"code\" 可拆分"},
      {"input_text": "applepenapple\n2\napple pen\n", "output_text": "true\n", "is_sample": true, "sample_explanation": "\"apple\" + \"pen\" + \"apple\" 可拆分"},
      {"input_text": "catsandog\n5\ncats dog sand and cat\n", "output_text": "false\n", "is_sample": true, "sample_explanation": "无法覆盖 \"og\"，返回 false"},
      {"input_text": "aaaaaaa\n2\na aa\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "aaaaaaa\n2\naaaa aaa\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "aaaaaaa\n1\naaaaaaa\n", "output_text": "true\n", "is_sample": false}
    ]
  },
  {
    "slug": "linked-list-cycle",
    "title": "环形链表",
    "difficulty": "EASY",
    "tags": ["链表", "双指针"],
    "content": "判断单链表是否存在环。输入提供链表节点值以及尾指向的环位置（pos）。可用快慢指针判环。",
    "input_description": "第一行整数 n；第二行 n 个整数为节点值；第三行整数 pos，表示尾节点链接的下标（0-based），若为 -1 表示无环。",
    "output_description": "有环输出 \"true\"，否则输出 \"false\"。",
    "constraints": "$1 \\le n \\le 10^{5}$，节点值绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "3\n3 2 0\n1\n", "output_text": "true\n", "is_sample": true, "sample_explanation": "尾指向索引 1，存在环"},
      {"input_text": "2\n1 2\n-1\n", "output_text": "false\n", "is_sample": true, "sample_explanation": "pos=-1 无环"},
      {"input_text": "1\n1\n0\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "3\n1 2 3\n-1\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "4\n1 2 3 4\n2\n", "output_text": "true\n", "is_sample": false}
    ]
  },
  {
    "slug": "linked-list-cycle-ii",
    "title": "环形链表 II",
    "difficulty": "MEDIUM",
    "tags": ["链表", "双指针"],
    "content": "在存在环的单链表中，返回环的入口节点值；若无环输出 \"null\"。输入提供节点值及尾指向位置。可用快慢指针相遇后再找入口。",
    "input_description": "第一行整数 n；第二行 n 个整数为节点值；第三行整数 pos（0-based，-1 表示无环）。",
    "output_description": "输出入口节点的值；无环输出 \"null\"。",
    "constraints": "$1 \\le n \\le 10^{5}$。",
    "testcases": [
      {"input_text": "3\n3 2 0\n1\n", "output_text": "2\n", "is_sample": true},
      {"input_text": "2\n1 2\n0\n", "output_text": "1\n", "is_sample": true},
      {"input_text": "2\n1 2\n-1\n", "output_text": "null\n", "is_sample": false},
      {"input_text": "4\n1 2 3 4\n3\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "5\n1 2 3 4 5\n2\n", "output_text": "3\n", "is_sample": false}
    ]
  },
  {
    "slug": "lru-cache",
    "title": "LRU 缓存",
    "difficulty": "MEDIUM",
    "tags": ["设计", "链表", "哈希表"],
    "content": "设计实现 LRU 缓存，支持 O(1) 的 get 和 put，容量固定。输入给出容量和操作序列，输出每次 get 的结果。",
    "input_description": "第一行整数 capacity；第二行整数 q 表示操作数；接下来 q 行操作，格式为 \"get key\" 或 \"put key value\"。",
    "output_description": "对每个 get 输出结果（未命中输出 -1），按出现顺序每行一个。put 无输出。",
    "constraints": "$1 \\le capacity,q \\le 10^{5}$，键值范围 |key|,|value| \\le 10^{9}$。",
    "testcases": [
      {"input_text": "2\n7\nput 1 1\nput 2 2\nget 1\nput 3 3\nget 2\nput 4 4\nget 1\nget 3\nget 4\n", "output_text": "1\n-1\n-1\n3\n4\n", "is_sample": true},
      {"input_text": "1\n3\nput 1 1\nput 2 2\nget 1\n", "output_text": "-1\n", "is_sample": false},
      {"input_text": "2\n4\nput 1 1\nput 2 2\nput 3 3\nget 2\n", "output_text": "2\n", "is_sample": false}
    ]
  },
  {
    "slug": "sort-list",
    "title": "排序链表",
    "difficulty": "MEDIUM",
    "tags": ["链表", "归并排序"],
    "content": "对单链表进行 O(n log n) 排序（升序），要求常数额外空间。需自行定义链表结构、读入并输出。",
    "input_description": "第一行整数 n，第二行 n 个整数为链表节点值。",
    "output_description": "输出排序后的链表节点值，空格分隔，行尾换行。",
    "constraints": "$0 \\le n \\le 10^{5}$，节点值绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "4\n4 2 1 3\n", "output_text": "1 2 3 4\n", "is_sample": true},
      {"input_text": "1\n-1\n", "output_text": "-1\n", "is_sample": true},
      {"input_text": "0\n\n", "output_text": "\n", "is_sample": false},
      {"input_text": "5\n-1 5 3 4 0\n", "output_text": "-1 0 3 4 5\n", "is_sample": false},
      {"input_text": "3\n2 2 1\n", "output_text": "1 2 2\n", "is_sample": false}
    ]
  },
  {
    "slug": "maximum-product-subarray",
    "title": "乘积最大子数组",
    "difficulty": "MEDIUM",
    "tags": ["数组", "动态规划"],
    "content": "给定整数数组，找出乘积最大的连续子数组的乘积（可为负）。需要同时维护当前最大/最小积以应对负数翻转。",
    "input_description": "第一行整数 n，第二行 n 个整数。",
    "output_description": "输出最大乘积，行尾换行。",
    "constraints": "$1 \\le n \\le 10^{5}$，元素绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "4\n2 3 -2 4\n", "output_text": "6\n", "is_sample": true, "sample_explanation": "最大积来自子数组 [2,3]"},
      {"input_text": "3\n-2 0 -1\n", "output_text": "0\n", "is_sample": true, "sample_explanation": "包含 0，最大为单个 0"},
      {"input_text": "1\n-3\n", "output_text": "-3\n", "is_sample": false},
      {"input_text": "3\n-2 -3 -4\n", "output_text": "12\n", "is_sample": false},
      {"input_text": "5\n-1 -2 -3 4 -1\n", "output_text": "24\n", "is_sample": false},
      {"input_text": "5\n0 2 -3 0 4\n", "output_text": "4\n", "is_sample": false}
    ]
  },
  {
    "slug": "min-stack",
    "title": "最小栈",
    "difficulty": "MEDIUM",
    "tags": ["设计", "栈"],
    "content": "设计支持 push、pop、top 和在 O(1) 时间内检索最小元素的栈。输入操作序列，输出 getMin 和 top 的结果。",
    "input_description": "第一行整数 q 表示操作数；接下来 q 行，每行一个操作：push x、pop、top、getMin。",
    "output_description": "对每个 top/getMin 输出结果（pop 若栈空可忽略）；各结果按出现顺序每行输出。",
    "constraints": "$1 \\le q \\le 10^{5}$，|x| \\le 10^{9}$。",
    "testcases": [
      {"input_text": "8\npush -2\npush 0\npush -3\ngetMin\ntop\npop\ngetMin\npop\n", "output_text": "-3\n-3\n-2\n", "is_sample": true, "sample_explanation": "最小值随压栈/出栈更新，输出依次为 -3、-3、-2"},
      {"input_text": "4\npush 1\ngetMin\npush 2\ngetMin\n", "output_text": "1\n1\n", "is_sample": false},
      {"input_text": "5\npush 2\npush 2\npop\ngetMin\ngetMin\n", "output_text": "2\n2\n", "is_sample": false}
    ]
  },
  {
    "slug": "intersection-of-two-linked-lists",
    "title": "相交链表",
    "difficulty": "EASY",
    "tags": ["链表", "双指针"],
    "content": "给定两单链表，找出它们的第一个相交节点的值；若不相交输出 \"null\"。输入给出两个链表的节点序列和相交起点位置。",
    "input_description": "第一行整数 n1，第二行 n1 个整数表示链表 A；第三行整数 n2，第四行 n2 个整数表示链表 B；第五行整数 skipA，第六行整数 skipB，表示 A 的第 skipA 节点与 B 的第 skipB 节点起开始共享后续节点（0-based）。若为 -1 表示不相交。",
    "output_description": "输出相交节点的值，或 \"null\"。",
    "constraints": "$0 \\le n1,n2 \\le 10^{5}$。",
    "testcases": [
      {"input_text": "3\n4 1 8\n3\n5 6 1\n1\n2\n", "output_text": "8\n", "is_sample": true, "sample_explanation": "链表在值 8 节点开始相交"},
      {"input_text": "3\n2 6 4\n3\n1 5 3\n-1\n-1\n", "output_text": "null\n", "is_sample": true, "sample_explanation": "不相交返回 null"},
      {"input_text": "1\n1\n1\n1\n0\n0\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "4\n9 8 7 6\n3\n1 2 3\n2\n1\n", "output_text": "7\n", "is_sample": false}
    ]
  },
  {
    "slug": "majority-element",
    "title": "多数元素",
    "difficulty": "EASY",
    "tags": ["数组", "投票算法"],
    "content": "给定大小为 n 的数组，找出出现次数大于 ⌊n/2⌋ 的元素，保证一定存在。经典 Boyer-Moore 投票算法 O(n) 时间 O(1) 空间。",
    "input_description": "第一行整数 n，第二行 n 个整数。",
    "output_description": "输出多数元素。",
    "constraints": "$1 \\le n \\le 10^{5}$，元素绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "3\n3 2 3\n", "output_text": "3\n", "is_sample": true},
      {"input_text": "7\n2 2 1 1 1 2 2\n", "output_text": "2\n", "is_sample": true},
      {"input_text": "5\n1 1 1 2 3\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "1\n5\n", "output_text": "5\n", "is_sample": false},
      {"input_text": "2\n-1 -1\n", "output_text": "-1\n", "is_sample": false}
    ]
  },
  {
    "slug": "house-robber",
    "title": "打家劫舍",
    "difficulty": "MEDIUM",
    "tags": ["动态规划", "数组"],
    "content": "一排房子，每间有一定金额，相邻房子不能同时偷，求最大可偷金额（一次遍历 DP）。",
    "input_description": "第一行整数 n，第二行 n 个非负整数表示金额。",
    "output_description": "输出最大金额，行尾换行。",
    "constraints": "$0 \\le n \\le 10^{5}$，金额不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "4\n1 2 3 1\n", "output_text": "4\n", "is_sample": true},
      {"input_text": "5\n2 7 9 3 1\n", "output_text": "12\n", "is_sample": true},
      {"input_text": "1\n5\n", "output_text": "5\n", "is_sample": false},
      {"input_text": "2\n2 1\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "3\n2 1 1\n", "output_text": "3\n", "is_sample": false},
      {"input_text": "6\n10 1 1 10 1 1\n", "output_text": "20\n", "is_sample": false}
    ]
  },
  {
    "slug": "number-of-islands",
    "title": "岛屿数量",
    "difficulty": "MEDIUM",
    "tags": ["DFS", "BFS", "并查集"],
    "content": "给定 0/1 网格，1 表示陆地，0 表示水，统计岛屿个数。岛屿由上下左右相邻的 1 连接而成，可用 DFS/BFS 或并查集。",
    "input_description": "第一行两个整数 m n；接下来 m 行，每行 n 个字符 0 或 1（无空格）。",
    "output_description": "输出岛屿数量，行尾换行。",
    "constraints": "$1 \\le m,n \\le 300$。",
    "testcases": [
      {"input_text": "4 5\n11110\n11010\n11000\n00000\n", "output_text": "1\n", "is_sample": true, "sample_explanation": "所有陆地连成一块，仅 1 个岛"},
      {"input_text": "4 5\n11000\n11000\n00100\n00011\n", "output_text": "3\n", "is_sample": true, "sample_explanation": "左上、中心、右下三块互不相连"},
      {"input_text": "1 1\n0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "1 1\n1\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "2 2\n10\n01\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "3 3\n111\n101\n111\n", "output_text": "1\n", "is_sample": false}
    ]
  },
  {
    "slug": "reverse-linked-list",
    "title": "反转链表",
    "difficulty": "EASY",
    "tags": ["链表"],
    "content": "将单链表原地反转，返回反转后的头节点。需自行定义链表、读入并输出节点值。",
    "input_description": "第一行整数 n，第二行 n 个整数表示链表节点值（头到尾）。",
    "output_description": "输出反转后的链表节点值，空格分隔；若为空输出空行。",
    "constraints": "$0 \\le n \\le 10^{5}$。",
    "testcases": [
      {"input_text": "5\n1 2 3 4 5\n", "output_text": "5 4 3 2 1\n", "is_sample": true},
      {"input_text": "1\n1\n", "output_text": "1\n", "is_sample": true},
      {"input_text": "0\n\n", "output_text": "\n", "is_sample": false},
      {"input_text": "3\n5 5 5\n", "output_text": "5 5 5\n", "is_sample": false},
      {"input_text": "2\n-1 10\n", "output_text": "10 -1\n", "is_sample": false}
    ]
  },
  {
    "slug": "course-schedule",
    "title": "课程表",
    "difficulty": "MEDIUM",
    "tags": ["图", "拓扑排序"],
    "content": "给定课程总数 numCourses 和若干先修依赖 [a,b]（完成 b 才能修 a），判断是否可以完成所有课程。等价于判定有向图是否有环，可用拓扑排序（入度 BFS）或 DFS 检测环。",
    "input_description": "第一行整数 numCourses，第二行整数 m；接下来 m 行每行两个整数 a b 表示依赖。",
    "output_description": "若可以完成输出 \"true\"，否则输出 \"false\"。",
    "constraints": "$1 \\le numCourses \\le 10^{5}$，$0 \\le m \\le 10^{5}$。",
    "testcases": [
      {"input_text": "2\n1\n1 0\n", "output_text": "true\n", "is_sample": true, "sample_explanation": "依赖链 0→1，无环，能完成"},
      {"input_text": "2\n2\n1 0\n0 1\n", "output_text": "false\n", "is_sample": true, "sample_explanation": "形成环 0↔1，无法完成全部课程"},
      {"input_text": "3\n2\n1 0\n2 1\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "3\n3\n1 0\n0 2\n2 1\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "4\n0\n", "output_text": "true\n", "is_sample": false}
    ]
  },
  {
    "slug": "implement-trie-prefix-tree",
    "title": "实现 Trie (前缀树)",
    "difficulty": "MEDIUM",
    "tags": ["设计", "字典树"],
    "content": "实现字典树，支持插入单词、完整单词查找、前缀查找。输入操作序列，输出 search / startsWith 结果。",
    "input_description": "第一行整数 q；之后 q 行操作：\"insert word\"、\"search word\"、\"startsWith prefix\"。",
    "output_description": "对每个 search/startsWith 输出 true/false，按顺序每行输出。",
    "constraints": "$1 \\le q \\le 10^{5}$，单词长度不超过 100。",
    "testcases": [
      {"input_text": "7\ninsert apple\nsearch apple\nsearch app\nstartsWith app\ninsert app\nsearch app\nstartsWith ap\n", "output_text": "true\nfalse\ntrue\ntrue\n", "is_sample": true},
      {"input_text": "3\ninsert a\nsearch a\nstartsWith b\n", "output_text": "true\nfalse\n", "is_sample": false},
      {"input_text": "4\ninsert hello\ninsert he\nsearch he\nstartsWith hel\n", "output_text": "true\ntrue\n", "is_sample": false}
    ]
  },
  {
    "slug": "kth-largest-element-in-an-array",
    "title": "数组中的第 K 个最大元素",
    "difficulty": "MEDIUM",
    "tags": ["堆", "快选"],
    "content": "在未排序数组中找出第 k 大的元素（1-based）。可用快速选择或小根堆。",
    "input_description": "第一行整数 n，第二行 n 个整数，第三行整数 k。",
    "output_description": "输出第 k 大的元素值。",
    "constraints": "$1 \\le n \\le 10^{5}$，元素绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "6\n3 2 1 5 6 4\n2\n", "output_text": "5\n", "is_sample": true, "sample_explanation": "排序后 [1,2,3,4,5,6]，第 2 大为 5"},
      {"input_text": "4\n-1 -1 -1 -1\n1\n", "output_text": "-1\n", "is_sample": true, "sample_explanation": "所有元素相同，第 1 大即 -1"},
      {"input_text": "1\n99\n1\n", "output_text": "99\n", "is_sample": false},
      {"input_text": "5\n7 10 4 3 20\n4\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "5\n7 10 4 3 20\n2\n", "output_text": "10\n", "is_sample": false}
    ]
  },
  {
    "slug": "the-skyline-problem",
    "title": "天际线问题",
    "difficulty": "HARD",
    "tags": ["扫描线", "堆"],
    "content": "给定城市建筑的轮廓，每个建筑用 [L, R, H] 表示左端、右端和高度，求从远处看到的天际线关键点序列。可用扫描线 + 最大堆记录当前高度。关键点在高度发生变化处输出。",
    "input_description": "第一行整数 n；接下来 n 行每行三个整数 L R H。",
    "output_description": "输出关键点序列，每行两个整数 x h，按 x 升序，表示高度变化点。",
    "constraints": "$0 \\le n \\le 10^{4}$，坐标与高度绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "5\n2 9 10\n3 7 15\n5 12 12\n15 20 10\n19 24 8\n", "output_text": "2 10\n3 15\n7 12\n12 0\n15 10\n20 8\n24 0\n", "is_sample": true, "sample_explanation": "扫描线高度变化点依次为 (2,10)->(3,15)->(7,12)->(12,0)->(15,10)->(20,8)->(24,0)"},
      {"input_text": "0\n", "output_text": "\n", "is_sample": true},
      {"input_text": "2\n0 2 3\n2 5 3\n", "output_text": "0 3\n5 0\n", "is_sample": false},
      {"input_text": "2\n0 2 3\n1 5 3\n", "output_text": "0 3\n5 0\n", "is_sample": false}
    ]
  },
  {
    "slug": "maximal-square",
    "title": "最大正方形",
    "difficulty": "MEDIUM",
    "tags": ["动态规划", "矩阵"],
    "content": "给定 0/1 矩阵，找出只包含 1 的最大正方形的面积。可用 DP 记录以该点为右下角的最大边长。",
    "input_description": "第一行两个整数 m n；接下来 m 行，每行一个长度为 n 的 0/1 字符串。",
    "output_description": "输出最大正方形面积。",
    "constraints": "$1 \\le m,n \\le 300$。",
    "testcases": [
      {"input_text": "4 5\n10100\n10111\n11111\n10010\n", "output_text": "4\n", "is_sample": true, "sample_explanation": "最大正方形边长 2，面积 4"},
      {"input_text": "1 1\n1\n", "output_text": "1\n", "is_sample": true, "sample_explanation": "单个 1，边长 1"},
      {"input_text": "1 4\n0000\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "2 2\n11\n11\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "3 3\n101\n111\n111\n", "output_text": "4\n", "is_sample": false}
    ]
  },
  {
    "slug": "invert-binary-tree",
    "title": "翻转二叉树",
    "difficulty": "EASY",
    "tags": ["树", "递归"],
    "content": "翻转二叉树（递归或 BFS 将左右子树交换），输出翻转后的层序序列。输入为层序，null 表示空。",
    "input_description": "第一行整数 m；第二行 m 个字符串为层序（整数或 null）。",
    "output_description": "输出翻转后的层序序列，空格分隔，null 表示空；空树输出空行。",
    "constraints": "$0 \\le m \\le 2000$。",
    "testcases": [
      {"input_text": "3\n4 2 7\n", "output_text": "4 7 2\n", "is_sample": true, "sample_explanation": "根 4 左右交换，2 与 7 互换"},
      {"input_text": "0\n\n", "output_text": "\n", "is_sample": true, "sample_explanation": "空树翻转仍为空"},
      {"input_text": "7\n1 2 3 4 5 6 7\n", "output_text": "1 3 2 7 6 5 4\n", "is_sample": false},
      {"input_text": "3\n1 null 2\n", "output_text": "1 2 null\n", "is_sample": false}
    ]
  },
  {
    "slug": "palindrome-linked-list",
    "title": "回文链表",
    "difficulty": "EASY",
    "tags": ["链表", "双指针"],
    "content": "判断单链表的值序列是否为回文。可用快慢指针+反转后半段或栈。需自行定义链表、读入并输出 true/false。",
    "input_description": "第一行整数 n，第二行 n 个整数。",
    "output_description": "回文输出 \"true\"，否则 \"false\"。",
    "constraints": "$0 \\le n \\le 10^{5}$。",
    "testcases": [
      {"input_text": "5\n1 2 3 2 1\n", "output_text": "true\n", "is_sample": true, "sample_explanation": "序列对称，回文"},
      {"input_text": "4\n1 2 2 1\n", "output_text": "true\n", "is_sample": true, "sample_explanation": "偶数长度亦对称"},
      {"input_text": "1\n1\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "2\n1 2\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "3\n1 0 1\n", "output_text": "true\n", "is_sample": false}
    ]
  },
  {
    "slug": "lowest-common-ancestor-of-a-binary-tree",
    "title": "二叉树的最近公共祖先",
    "difficulty": "MEDIUM",
    "tags": ["树", "DFS"],
    "content": "在普通二叉树中，给定两节点值 p、q，求它们的最近公共祖先节点值（节点值唯一）。可用递归自底向上判断。",
    "input_description": "第一行整数 m；第二行 m 个字符串为层序（整数或 null）；第三行两个整数 p q。",
    "output_description": "输出最近公共祖先的节点值，若不存在输出 \"null\"。",
    "constraints": "$1 \\le m \\le 2000$。",
    "testcases": [
      {"input_text": "7\n3 5 1 6 2 0 8 null null 7 4\n5 1\n", "output_text": "3\n", "is_sample": true, "sample_explanation": "5、1 分处左右子树，LCA 为根 3"},
      {"input_text": "7\n3 5 1 6 2 0 8 null null 7 4\n5 4\n", "output_text": "5\n", "is_sample": true, "sample_explanation": "4 在节点 5 的子树内，LCA 为 5"},
      {"input_text": "3\n1 2 3\n2 3\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "1\n1\n1 1\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "3\n1 null 2\n1 2\n", "output_text": "1\n", "is_sample": false}
    ]
  },
  {
    "slug": "product-of-array-except-self",
    "title": "除自身以外数组的乘积",
    "difficulty": "MEDIUM",
    "tags": ["数组", "前后缀"],
    "content": "返回数组 output，其中 output[i] 为除 nums[i] 外所有元素乘积，要求 O(n) 时间且不用除法，可用前后缀积。",
    "input_description": "第一行整数 n，第二行 n 个整数。",
    "output_description": "输出结果数组，空格分隔。",
    "constraints": "$2 \\le n \\le 10^{5}$，元素绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "4\n1 2 3 4\n", "output_text": "24 12 8 6\n", "is_sample": true, "sample_explanation": "位置 0 的积为 2*3*4=24，以此类推"},
      {"input_text": "5\n-1 1 0 -3 3\n", "output_text": "0 0 9 0 0\n", "is_sample": true, "sample_explanation": "含一个 0 时，只有含 0 的位置得非零（其余含 0）"},
      {"input_text": "3\n0 0 3\n", "output_text": "0 0 0\n", "is_sample": false},
      {"input_text": "3\n1 -1 1\n", "output_text": "-1 1 -1\n", "is_sample": false},
      {"input_text": "2\n2 3\n", "output_text": "3 2\n", "is_sample": false}
    ]
  },
  {
    "slug": "sliding-window-maximum",
    "title": "滑动窗口最大值",
    "difficulty": "HARD",
    "tags": ["单调队列", "滑动窗口"],
    "content": "给定数组和窗口大小 k，返回每个窗口的最大值，按出现顺序输出。典型解法为单调队列维护当前窗口最大值。",
    "input_description": "第一行整数 n，第二行 n 个整数，第三行整数 k。",
    "output_description": "输出窗口最大值数组，空格分隔。",
    "constraints": "$1 \\le k \\le n \\le 10^{5}$。",
    "testcases": [
      {"input_text": "8\n1 3 -1 -3 5 3 6 7\n3\n", "output_text": "3 3 5 5 6 7\n", "is_sample": true, "sample_explanation": "窗口逐步右移，保持队列递减，输出 6 个最大值"},
      {"input_text": "1\n1\n1\n", "output_text": "1\n", "is_sample": true, "sample_explanation": "单元素窗口即自身"},
      {"input_text": "3\n9 8 7\n2\n", "output_text": "9 8\n", "is_sample": false},
      {"input_text": "5\n1 2 3 4 5\n1\n", "output_text": "1 2 3 4 5\n", "is_sample": false},
      {"input_text": "5\n5 4 3 2 1\n2\n", "output_text": "5 4 3 2\n", "is_sample": false}
    ]
  },
  {
    "slug": "search-a-2d-matrix-ii",
    "title": "搜索二维矩阵 II",
    "difficulty": "MEDIUM",
    "tags": ["矩阵", "二分", "双指针"],
    "content": "在行列均升序的矩阵中查找 target，返回 true/false。可从右上角或左下角按“折线”二分移动。",
    "input_description": "第一行两个整数 m n；接下来 m 行，每行 n 个整数；最后一行整数 target。",
    "output_description": "找到输出 \"true\"，否则 \"false\"。",
    "constraints": "$1 \\le m,n \\le 300$。",
    "testcases": [
      {"input_text": "5 5\n1 4 7 11 15\n2 5 8 12 19\n3 6 9 16 22\n10 13 14 17 24\n18 21 23 26 30\n5\n", "output_text": "true\n", "is_sample": true, "sample_explanation": "从右上角开始，逐步逼近目标 5"},
      {"input_text": "2 2\n1 2\n3 4\n5\n", "output_text": "false\n", "is_sample": true, "sample_explanation": "矩阵最大值 4，小于目标 5"},
      {"input_text": "1 1\n-1\n-1\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "1 2\n1 3\n2\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "3 3\n1 2 3\n4 5 6\n7 8 9\n8\n", "output_text": "true\n", "is_sample": false}
    ]
  },
  {
    "slug": "perfect-squares",
    "title": "完全平方数",
    "difficulty": "MEDIUM",
    "tags": ["动态规划", "数论"],
    "content": "给定正整数 n，求最少需要多少个完全平方数相加得到 n。",
    "input_description": "一行整数 n。",
    "output_description": "输出最少数量，行尾换行。",
    "constraints": "$1 \\le n \\le 10^{4}$。",
    "testcases": [
      {"input_text": "12\n", "output_text": "3\n", "is_sample": true, "sample_explanation": "12=4+4+4，最少 3 个"},
      {"input_text": "13\n", "output_text": "2\n", "is_sample": true, "sample_explanation": "13=4+9，最少 2 个"},
      {"input_text": "1\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "2\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "3\n", "output_text": "3\n", "is_sample": false},
      {"input_text": "4\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "43\n", "output_text": "3\n", "is_sample": false}
    ]
  },
  {
    "slug": "find-the-duplicate-number",
    "title": "寻找重复数",
    "difficulty": "MEDIUM",
    "tags": ["数组", "快慢指针", "二分"],
    "content": "给定包含 n+1 个整数的数组 nums，取值范围 1..n，至少有一个重复数，找出任意一个重复数，不允许修改数组。",
    "input_description": "第一行整数 n（实际数组长度为 n+1），第二行 n+1 个整数。",
    "output_description": "输出任意一个重复的数字。",
    "constraints": "$1 \\le n \\le 10^{5}$。",
    "testcases": [
      {"input_text": "4\n1 3 4 2 2\n", "output_text": "2\n", "is_sample": true},
      {"input_text": "5\n3 1 3 4 2 3\n", "output_text": "3\n", "is_sample": true},
      {"input_text": "2\n1 1 2\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "3\n2 2 2 2\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "3\n1 3 4 2\n", "output_text": "NONE\n", "is_sample": false}
    ]
  },
  {
    "slug": "serialize-and-deserialize-binary-tree",
    "title": "二叉树的序列化与反序列化",
    "difficulty": "HARD",
    "tags": ["设计", "树"],
    "content": "设计算法将二叉树序列化为字符串并能还原。输入给出层序字符串，要求输出序列化后再反序列化后的层序，以验证功能。",
    "input_description": "第一行整数 m；第二行 m 个字符串（整数或 null）为层序。",
    "output_description": "输出反序列化后树的层序（空指针用 null），空树输出空行。",
    "constraints": "$0 \\le m \\le 2000$。",
    "testcases": [
      {"input_text": "7\n1 2 3 null null 4 5\n", "output_text": "1 2 3 null null 4 5\n", "is_sample": true},
      {"input_text": "0\n\n", "output_text": "\n", "is_sample": true},
      {"input_text": "1\n1\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "3\n1 2 3\n", "output_text": "1 2 3\n", "is_sample": false},
      {"input_text": "3\n1 null 2\n", "output_text": "1 null 2\n", "is_sample": false}
    ]
  },
  {
    "slug": "longest-increasing-subsequence",
    "title": "最长递增子序列",
    "difficulty": "MEDIUM",
    "tags": ["动态规划", "二分"],
    "content": "给定整数数组，求最长严格递增子序列长度。",
    "input_description": "第一行整数 n，第二行 n 个整数。",
    "output_description": "输出 LIS 长度，行尾换行。",
    "constraints": "$1 \\le n \\le 10^{5}$。",
    "testcases": [
      {"input_text": "8\n10 9 2 5 3 7 101 18\n", "output_text": "4\n", "is_sample": true},
      {"input_text": "6\n0 1 0 3 2 3\n", "output_text": "4\n", "is_sample": true},
      {"input_text": "1\n1\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "5\n5 4 3 2 1\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "5\n1 2 3 4 5\n", "output_text": "5\n", "is_sample": false}
    ]
  },
  {
    "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
    "title": "买卖股票的最佳时机含冷冻期",
    "difficulty": "MEDIUM",
    "tags": ["动态规划"],
    "content": "可多次交易股票，但卖出后次日必须冷冻不能买，求最大利润。",
    "input_description": "第一行整数 n，第二行 n 个整数表示股价。",
    "output_description": "输出最大利润整数。",
    "constraints": "$1 \\le n \\le 10^{5}$。",
    "testcases": [
      {"input_text": "5\n1 2 3 0 2\n", "output_text": "3\n", "is_sample": true},
      {"input_text": "2\n1 2\n", "output_text": "1\n", "is_sample": true},
      {"input_text": "4\n2 1 4 5\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "5\n1 2 3 4 5\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "3\n5 4 3\n", "output_text": "0\n", "is_sample": false}
    ]
  },
  {
    "slug": "burst-balloons",
    "title": "戳气球",
    "difficulty": "HARD",
    "tags": ["区间 DP"],
    "content": "给定气球数字数组 nums，每次戳破一个气球得分为其左右未戳气球数字与自身相乘。求最大得分。",
    "input_description": "第一行整数 n，第二行 n 个整数。",
    "output_description": "输出最大得分整数。",
    "constraints": "$1 \\le n \\le 500$，$1 \\le nums[i] \\le 100$。",
    "testcases": [
      {"input_text": "4\n3 1 5 8\n", "output_text": "167\n", "is_sample": true},
      {"input_text": "3\n1 5 3\n", "output_text": "35\n", "is_sample": true},
      {"input_text": "1\n5\n", "output_text": "5\n", "is_sample": false},
      {"input_text": "2\n1 1\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "5\n8 2 6 8 1\n", "output_text": "560\n", "is_sample": false}
    ]
  },
  {
    "slug": "coin-change",
    "title": "零钱兑换",
    "difficulty": "MEDIUM",
    "tags": ["动态规划"],
    "content": "给定硬币面额和总金额，求组成该金额所需最少硬币数；无法组成返回 -1。典型完全背包 DP。",
    "input_description": "第一行整数 n，第二行 n 个正整数表示面额；第三行整数 amount。",
    "output_description": "输出最少硬币数或 -1。",
    "constraints": "$1 \\le n \\le 50$，$1 \\le amount \\le 10^{4}$。",
    "testcases": [
      {"input_text": "3\n1 2 5\n11\n", "output_text": "3\n", "is_sample": true, "sample_explanation": "11=5+5+1 最少 3 枚"},
      {"input_text": "2\n2 5\n3\n", "output_text": "-1\n", "is_sample": true, "sample_explanation": "无法用 2/5 组成 3"},
      {"input_text": "1\n1\n0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "1\n2\n3\n", "output_text": "-1\n", "is_sample": false},
      {"input_text": "2\n1 2\n100\n", "output_text": "50\n", "is_sample": false}
    ]
  },
  {
    "slug": "house-robber-iii",
    "title": "打家劫舍 III",
    "difficulty": "MEDIUM",
    "tags": ["树", "动态规划"],
    "content": "房屋排列成二叉树，相邻节点不能同时偷，求最大金额。",
    "input_description": "第一行整数 m；第二行 m 个字符串为层序（整数或 null）。",
    "output_description": "输出最大金额整数。",
    "constraints": "$0 \\le m \\le 2000$。",
    "testcases": [
      {"input_text": "7\n3 2 3 null 3 null 1\n", "output_text": "7\n", "is_sample": true},
      {"input_text": "3\n3 4 5\n", "output_text": "9\n", "is_sample": true},
      {"input_text": "1\n5\n", "output_text": "5\n", "is_sample": false},
      {"input_text": "0\n\n", "output_text": "0\n", "is_sample": false}
    ]
  },
  {
    "slug": "counting-bits",
    "title": "比特位计数",
    "difficulty": "EASY",
    "tags": ["动态规划", "位运算"],
    "content": "对于每个 0..n 的整数，求其二进制中 1 的个数，返回数组。",
    "input_description": "一行整数 n。",
    "output_description": "输出 0..n 的 1 数量，空格分隔。",
    "constraints": "$0 \\le n \\le 10^{5}$。",
    "testcases": [
      {"input_text": "2\n", "output_text": "0 1 1\n", "is_sample": true},
      {"input_text": "5\n", "output_text": "0 1 1 2 1 2\n", "is_sample": true},
      {"input_text": "0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "1\n", "output_text": "0 1\n", "is_sample": false}
    ]
  },
  {
    "slug": "top-k-frequent-elements",
    "title": "前 K 个高频元素",
    "difficulty": "MEDIUM",
    "tags": ["堆", "桶排序"],
    "content": "给定整数数组和 k，返回出现频率最高的 k 个元素，输出顺序不限。",
    "input_description": "第一行整数 n，第二行 n 个整数，第三行整数 k。",
    "output_description": "输出 k 个整数，空格分隔。",
    "constraints": "$1 \\le k \\le n \\le 10^{5}$。",
    "testcases": [
      {"input_text": "6\n1 1 1 2 2 3\n2\n", "output_text": "1 2\n", "is_sample": true},
      {"input_text": "1\n1\n1\n", "output_text": "1\n", "is_sample": true},
      {"input_text": "5\n4 1 2 2 3\n2\n", "output_text": "2 1\n", "is_sample": false},
      {"input_text": "6\n7 7 7 8 8 9\n1\n", "output_text": "7\n", "is_sample": false}
    ]
  },
  {
    "slug": "decode-string",
    "title": "字符串解码",
    "difficulty": "MEDIUM",
    "tags": ["栈", "字符串"],
    "content": "解码形如 k[encoded_string] 的嵌套重复字符串，k 为正整数。",
    "input_description": "一行字符串 s。",
    "output_description": "输出解码后的字符串。",
    "constraints": "$1 \\le |s| \\le 10^{5}$。",
    "testcases": [
      {"input_text": "3[a]2[bc]\n", "output_text": "aaabcbc\n", "is_sample": true},
      {"input_text": "3[a2[c]]\n", "output_text": "accaccacc\n", "is_sample": true},
      {"input_text": "2[abc]3[cd]ef\n", "output_text": "abcabccdcdcdef\n", "is_sample": false},
      {"input_text": "abc3[cd]xyz\n", "output_text": "abccdcdcdxyz\n", "is_sample": false}
    ]
  },
  {
    "slug": "queue-reconstruction-by-height",
    "title": "根据身高重建队列",
    "difficulty": "MEDIUM",
    "tags": ["贪心", "排序"],
    "content": "每个人用 [h, k] 表示身高和前面不矮于他的人的数量，重建原队列顺序。",
    "input_description": "第一行整数 n，接下来 n 行每行两个整数 h k。",
    "output_description": "输出重建后的队列，每行两个整数。",
    "constraints": "$1 \\le n \\le 10^{4}$。",
    "testcases": [
      {"input_text": "6\n7 0\n4 4\n7 1\n5 0\n6 1\n5 2\n", "output_text": "5 0\n7 0\n5 2\n6 1\n4 4\n7 1\n", "is_sample": true},
      {"input_text": "3\n6 0\n5 0\n4 0\n", "output_text": "4 0\n5 0\n6 0\n", "is_sample": false},
      {"input_text": "3\n6 2\n5 1\n4 0\n", "output_text": "4 0\n5 1\n6 2\n", "is_sample": false}
    ]
  },
  {
    "slug": "partition-equal-subset-sum",
    "title": "分割等和子集",
    "difficulty": "MEDIUM",
    "tags": ["动态规划", "背包"],
    "content": "判断是否可将数组分为两个子集使元素和相等。",
    "input_description": "第一行整数 n，第二行 n 个正整数。",
    "output_description": "可分割输出 \"true\"，否则 \"false\"。",
    "constraints": "$1 \\le n \\le 200$，元素不超过 100。",
    "testcases": [
      {"input_text": "4\n1 5 11 5\n", "output_text": "true\n", "is_sample": true},
      {"input_text": "3\n1 2 3\n", "output_text": "false\n", "is_sample": true},
      {"input_text": "5\n2 2 3 5 5\n", "output_text": "false\n", "is_sample": false},
      {"input_text": "5\n2 2 3 5 4\n", "output_text": "true\n", "is_sample": false}
    ]
  },
  {
    "slug": "path-sum-iii",
    "title": "路径总和 III",
    "difficulty": "MEDIUM",
    "tags": ["树", "前缀和"],
    "content": "给定二叉树和整数 target，统计路径和等于 target 的路径数。路径需向下但可从任意节点开始。",
    "input_description": "第一行整数 m；第二行 m 个字符串为层序（整数或 null）；第三行整数 target。",
    "output_description": "输出路径数量，行尾换行。",
    "constraints": "$0 \\le m \\le 2000$。",
    "testcases": [
      {"input_text": "11\n10 5 -3 3 2 null 11 3 -2 null 1\n8\n", "output_text": "3\n", "is_sample": true},
      {"input_text": "1\n1\n1\n", "output_text": "1\n", "is_sample": true},
      {"input_text": "0\n\n0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "3\n1 -2 -3\n-1\n", "output_text": "1\n", "is_sample": false}
    ]
  },
  {
    "slug": "find-all-anagrams-in-a-string",
    "title": "找到字符串中所有字母异位词",
    "difficulty": "MEDIUM",
    "tags": ["滑动窗口", "字符串"],
    "content": "在字符串 s 中找到所有与 p 为字母异位词的子串起始下标，返回按升序的下标列表。",
    "input_description": "第一行字符串 s，第二行字符串 p。",
    "output_description": "输出起始下标，空格分隔；无则输出空行。",
    "constraints": "$1 \\le |s|,|p| \\le 10^{5}$。",
    "testcases": [
      {"input_text": "cbaebabacd\nabc\n", "output_text": "0 6\n", "is_sample": true},
      {"input_text": "abab\nab\n", "output_text": "0 1 2\n", "is_sample": true},
      {"input_text": "aaaaa\naaa\n", "output_text": "0 1 2\n", "is_sample": false},
      {"input_text": "abc\nabcd\n", "output_text": "\n", "is_sample": false}
    ]
  },
  {
    "slug": "find-all-numbers-disappeared-in-an-array",
    "title": "找到所有数组中消失的数字",
    "difficulty": "EASY",
    "tags": ["数组"],
    "content": "给定 1..n 范围数组（长度 n），部分数字缺失、部分重复，找出所有未出现的数字，要求 O(1) 额外空间。",
    "input_description": "第一行整数 n，第二行 n 个整数。",
    "output_description": "输出缺失的数字，空格分隔，按升序；若无缺失输出空行。",
    "constraints": "$1 \\le n \\le 10^{5}$。",
    "testcases": [
      {"input_text": "8\n4 3 2 7 8 2 3 1\n", "output_text": "5 6\n", "is_sample": true},
      {"input_text": "2\n1 1\n", "output_text": "2\n", "is_sample": true},
      {"input_text": "1\n1\n", "output_text": "\n", "is_sample": false},
      {"input_text": "5\n2 2 2 2 2\n", "output_text": "1 3 4 5\n", "is_sample": false}
    ]
  },
  {
    "slug": "hamming-distance",
    "title": "汉明距离",
    "difficulty": "EASY",
    "tags": ["位运算"],
    "content": "两个整数的汉明距离是其二进制对应位不同的个数，计算该值。",
    "input_description": "一行两个整数 x y。",
    "output_description": "输出汉明距离整数。",
    "constraints": "$0 \\le x,y \\le 2^{31}-1$。",
    "testcases": [
      {"input_text": "1 4\n", "output_text": "2\n", "is_sample": true},
      {"input_text": "3 1\n", "output_text": "1\n", "is_sample": true},
      {"input_text": "0 0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "7 10\n", "output_text": "3\n", "is_sample": false}
    ]
  },
  {
    "slug": "target-sum",
    "title": "目标和",
    "difficulty": "MEDIUM",
    "tags": ["动态规划", "回溯"],
    "content": "给定数组 nums 和目标值 S，给每个数前添加 + 或 -，问有多少种方式使表达式结果等于 S。",
    "input_description": "第一行整数 n，第二行 n 个整数，第三行整数 S。",
    "output_description": "输出方案数，行尾换行。",
    "constraints": "$1 \\le n \\le 20$，元素绝对值不超过 1000，确保结果在 32 位整数范围。",
    "testcases": [
      {"input_text": "5\n1 1 1 1 1\n3\n", "output_text": "5\n", "is_sample": true},
      {"input_text": "2\n1 2\n1\n", "output_text": "1\n", "is_sample": true},
      {"input_text": "3\n1 2 3\n-2\n", "output_text": "1\n", "is_sample": false},
      {"input_text": "4\n1 0 0 0\n1\n", "output_text": "4\n", "is_sample": false}
    ]
  },
  {
    "slug": "convert-bst-to-greater-tree",
    "title": "把二叉搜索树转换为累加树",
    "difficulty": "MEDIUM",
    "tags": ["树", "DFS"],
    "content": "将 BST 每个节点值替换为原树中所有大于等于它的节点值之和，输出转换后的层序。",
    "input_description": "第一行整数 m；第二行 m 个字符串为层序（整数或 null）。",
    "output_description": "输出转换后的层序，空格分隔，null 表示空。",
    "constraints": "$0 \\le m \\le 2000$。",
    "testcases": [
      {"input_text": "3\n2 1 3\n", "output_text": "5 6 3\n", "is_sample": true},
      {"input_text": "7\n5 2 13 1 3 null 15\n", "output_text": "33 36 15 37 35 null 15\n", "is_sample": true},
      {"input_text": "0\n\n", "output_text": "\n", "is_sample": false},
      {"input_text": "1\n1\n", "output_text": "1\n", "is_sample": false}
    ]
  },
  {
    "slug": "diameter-of-binary-tree",
    "title": "二叉树的直径",
    "difficulty": "EASY",
    "tags": ["树", "DFS"],
    "content": "求二叉树中两节点间最长路径的边数（可不经过根）。",
    "input_description": "第一行整数 m；第二行 m 个字符串为层序（整数或 null）。",
    "output_description": "输出直径边数，行尾换行。",
    "constraints": "$0 \\le m \\le 2000$。",
    "testcases": [
      {"input_text": "5\n1 2 3 4 5\n", "output_text": "3\n", "is_sample": true},
      {"input_text": "1\n1\n", "output_text": "0\n", "is_sample": true},
      {"input_text": "0\n\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "3\n1 2 3\n", "output_text": "2\n", "is_sample": false}
    ]
  },
  {
    "slug": "subarray-sum-equals-k",
    "title": "和为 K 的子数组",
    "difficulty": "MEDIUM",
    "tags": ["前缀和", "哈希表"],
    "content": "给定整数数组和整数 k，统计和为 k 的连续子数组个数。",
    "input_description": "第一行整数 n，第二行 n 个整数，第三行整数 k。",
    "output_description": "输出子数组个数。",
    "constraints": "$1 \\le n \\le 10^{5}$，元素绝对值不超过 $10^{9}$。",
    "testcases": [
      {"input_text": "3\n1 1 1\n2\n", "output_text": "2\n", "is_sample": true},
      {"input_text": "4\n1 2 3\n3\n", "output_text": "2\n", "is_sample": true},
      {"input_text": "3\n1 -1 0\n0\n", "output_text": "3\n", "is_sample": false},
      {"input_text": "5\n1 2 1 2 1\n3\n", "output_text": "4\n", "is_sample": false}
    ]
  },
  {
    "slug": "subtree-of-another-tree",
    "title": "另一棵树的子树",
    "difficulty": "EASY",
    "tags": ["树", "DFS"],
    "content": "判断树 t 是否为树 s 的子树（结构和值完全相同）。",
    "input_description": "第一行整数 m1，第二行 m1 个字符串为树 s 层序；第三行整数 m2，第四行 m2 个字符串为树 t 层序。",
    "output_description": "是子树输出 \"true\"，否则 \"false\"。",
    "constraints": "$0 \\le m1,m2 \\le 2000$。",
    "testcases": [
      {"input_text": "7\n3 4 5 1 2 null null null null null null\n3\n4 1 2\n", "output_text": "true\n", "is_sample": true},
      {"input_text": "7\n3 4 5 1 2 null null null null 0\n3\n4 1 2\n", "output_text": "false\n", "is_sample": true},
      {"input_text": "0\n\n0\n\n", "output_text": "true\n", "is_sample": false},
      {"input_text": "1\n1\n1\n1\n", "output_text": "true\n", "is_sample": false}
    ]
  },
  {
    "slug": "shortest-unsorted-continuous-subarray",
    "title": "最短无序连续子数组",
    "difficulty": "MEDIUM",
    "tags": ["数组"],
    "content": "找到最短的连续子数组，若将其排序则整个数组有序，输出该子数组长度。",
    "input_description": "第一行整数 n，第二行 n 个整数。",
    "output_description": "输出长度整数。",
    "constraints": "$1 \\le n \\le 10^{5}$。",
    "testcases": [
      {"input_text": "5\n2 6 4 8 10\n", "output_text": "3\n", "is_sample": true},
      {"input_text": "2\n1 2\n", "output_text": "0\n", "is_sample": true},
      {"input_text": "5\n1 3 2 2 2\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "4\n2 1 3 4\n", "output_text": "2\n", "is_sample": false},
      {"input_text": "5\n1 2 3 4 5\n", "output_text": "0\n", "is_sample": false}
    ]
  },
  {
    "slug": "merge-two-binary-trees",
    "title": "合并二叉树",
    "difficulty": "EASY",
    "tags": ["树"],
    "content": "给定两棵二叉树，将它们合并：重叠节点值相加，不重叠节点直接连接。",
    "input_description": "第一行整数 m1，第二行 m1 个字符串为树 A 层序；第三行整数 m2，第四行 m2 个字符串为树 B 层序。",
    "output_description": "输出合并后树的层序，空节点用 null。",
    "constraints": "$0 \\le m1,m2 \\le 2000$。",
    "testcases": [
      {"input_text": "7\n1 3 2 5 null null null\n7\n2 1 3 null 4 null 7\n", "output_text": "3 4 5 5 4 null 7\n", "is_sample": true},
      {"input_text": "0\n\n0\n\n", "output_text": "\n", "is_sample": true},
      {"input_text": "1\n1\n1\n2\n", "output_text": "3\n", "is_sample": false}
    ]
  },
  {
    "slug": "task-scheduler",
    "title": "任务调度器",
    "difficulty": "MEDIUM",
    "tags": ["贪心", "堆"],
    "content": "给定任务列表（字母 A-Z）和冷却时间 n，CPU 每单位时间做一个任务或空闲，求完成所有任务的最少时间单位数。典型贪心：按最高频任务填充空档，或用公式/大顶堆模拟。",
    "input_description": "第一行整数 t，表示任务数量；第二行 t 个大写字母；第三行整数 n。",
    "output_description": "输出最少时间单位数。",
    "constraints": "$1 \\le t \\le 10^{5}$，$0 \\le n \\le 10^{5}$。",
    "testcases": [
      {"input_text": "6\nA A A B B B\n2\n", "output_text": "8\n", "is_sample": true, "sample_explanation": "最优序列 A B idle A B idle A B 共 8 单位"},
      {"input_text": "1\nA\n0\n", "output_text": "1\n", "is_sample": true, "sample_explanation": "无冷却，执行一次即可"},
      {"input_text": "3\nA A A\n3\n", "output_text": "7\n", "is_sample": false},
      {"input_text": "4\nA A A A\n2\n", "output_text": "13\n", "is_sample": false},
      {"input_text": "4\nA B C D\n2\n", "output_text": "4\n", "is_sample": false}
    ]
  },
  {
    "slug": "palindromic-substrings",
    "title": "回文子串",
    "difficulty": "MEDIUM",
    "tags": ["动态规划", "中心扩展"],
    "content": "计算字符串中回文子串的数量（不同位置视为不同子串）。可用中心扩展或 DP 统计所有回文中心。",
    "input_description": "一行字符串 s。",
    "output_description": "输出回文子串总数，行尾换行。",
    "constraints": "$0 \\le |s| \\le 2000$。",
    "testcases": [
      {"input_text": "abc\n", "output_text": "3\n", "is_sample": true, "sample_explanation": "仅 a,b,c 三个单字符回文"},
      {"input_text": "aaa\n", "output_text": "6\n", "is_sample": true, "sample_explanation": "3 个单字符 + 2 个长度 2 + 1 个长度 3 共 6"},
      {"input_text": "\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "ababa\n", "output_text": "9\n", "is_sample": false},
      {"input_text": "abca\n", "output_text": "4\n", "is_sample": false}
    ]
  },
  {
    "slug": "max-area-of-island",
    "title": "岛屿的最大面积",
    "difficulty": "MEDIUM",
    "tags": ["DFS", "BFS"],
    "content": "给定 0/1 网格，求最大连通陆地块的格子数（面积）。上下左右为邻接，可用 DFS/BFS 遍历并计数。",
    "input_description": "第一行两个整数 m n；接下来 m 行 n 个 0/1（无空格）。",
    "output_description": "输出最大岛屿面积，行尾换行。",
    "constraints": "$1 \\le m,n \\le 50$。",
    "testcases": [
      {"input_text": "3 3\n000\n010\n000\n", "output_text": "1\n", "is_sample": true},
      {"input_text": "3 3\n111\n010\n111\n", "output_text": "4\n", "is_sample": true},
      {"input_text": "1 1\n0\n", "output_text": "0\n", "is_sample": false},
      {"input_text": "2 2\n11\n11\n", "output_text": "4\n", "is_sample": false},
      {"input_text": "3 4\n1100\n1100\n0011\n", "output_text": "4\n", "is_sample": false}
    ]
  }
]
